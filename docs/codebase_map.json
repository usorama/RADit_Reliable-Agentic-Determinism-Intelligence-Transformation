{
  "$schema": "./codebase_map.schema.json",
  "meta": {
    "version": "1.0.0",
    "generated_at": "2025-12-30T13:57:43.248238+00:00",
    "project_name": "RADit - Reliable Agentic Determinism Intelligence Transformation",
    "description": "AI agent workbench enforcing deterministic SDLC through TDD, multi-agent orchestration, and MCP integration"
  },
  "packages": {
    "daw-agents": {
      "name": "daw-agents",
      "language": "python",
      "path": "packages/daw-agents",
      "description": "Python backend with FastAPI, LangGraph agents, and MCP integration",
      "domains": {
        "root": {
          "name": "root",
          "path": "src/daw_agents",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/__init__.py",
              "description": "DAW Agents package."
            },
            {
              "name": "main.py",
              "path": "daw_agents/main.py",
              "description": "DAW Backend - Deterministic Agentic Workbench.",
              "functions": [
                {
                  "name": "health_check",
                  "line": 21,
                  "description": "Health check endpoint.",
                  "async": true,
                  "return_type": "dict[str, str]"
                }
              ],
              "imports": [
                {
                  "module": "fastapi",
                  "names": [
                    "FastAPI"
                  ],
                  "is_relative": false
                },
                {
                  "module": "fastapi.middleware.cors",
                  "names": [
                    "CORSMiddleware"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        },
        "context": {
          "name": "context",
          "path": "src/daw_agents/context",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/context/__init__.py",
              "description": "Context management module for DAW Agent Workbench.",
              "imports": [
                {
                  "module": "daw_agents.context.compaction",
                  "names": [
                    "CompactionConfig",
                    "ContextCompactor",
                    "Message",
                    "Summary"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "CompactionConfig",
                "ContextCompactor",
                "Message",
                "Summary"
              ]
            },
            {
              "name": "compaction.py",
              "path": "daw_agents/context/compaction.py",
              "description": "Context Compaction module for managing conversation history.",
              "classes": [
                {
                  "name": "Message",
                  "line": 42,
                  "description": "Model representing a chat message.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "role",
                      "line": 45,
                      "type": "str"
                    },
                    {
                      "name": "content",
                      "line": 46,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "Summary",
                  "line": 49,
                  "description": "Model representing a compacted summary of messages.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "content",
                      "line": 52,
                      "type": "str"
                    },
                    {
                      "name": "conversation_id",
                      "line": 53,
                      "type": "str"
                    },
                    {
                      "name": "message_count",
                      "line": 54,
                      "type": "int"
                    },
                    {
                      "name": "start_index",
                      "line": 55,
                      "type": "int"
                    },
                    {
                      "name": "end_index",
                      "line": 56,
                      "type": "int"
                    },
                    {
                      "name": "token_count",
                      "line": 57,
                      "type": "int"
                    },
                    {
                      "name": "created_at",
                      "line": 58,
                      "type": "datetime"
                    }
                  ]
                },
                {
                  "name": "CompactionConfig",
                  "line": 64,
                  "description": "Configuration for context compaction behavior.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "max_tokens",
                      "line": 67,
                      "type": "int"
                    },
                    {
                      "name": "summary_model_type",
                      "line": 71,
                      "type": "TaskType"
                    },
                    {
                      "name": "recent_messages_to_keep",
                      "line": 75,
                      "type": "int"
                    },
                    {
                      "name": "messages_per_summary",
                      "line": 79,
                      "type": "int"
                    },
                    {
                      "name": "encoding_name",
                      "line": 83,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "ContextCompactor",
                  "line": 89,
                  "description": "Manages conversation history compaction for context window management.\n\nThis class provides:\n1. Token counting for messages using tiktoken\n2. LLM-based summarization of message groups\n3. Context compaction with recency bias\n4. Neo4j storage for persistent summaries\n5. Retrieval of relevant summaries\n\nArchitecture:\n- Recent messages (configurable count) are kept intact\n- Older messages are grouped and summarized\n- Summaries are stored in Neo4j for future retrieval\n- Total output stays within token limit\n\nExample:\n    ```python\n    router = ModelRouter()\n    compactor = ContextCompactor(model_router=router)\n\n    messages = [Message(role=\"user\", content=f\"Message {i}\") for i in range(100)]\n    compacted = await compactor.compact(messages, max_tokens=4000)\n    # compacted will have summaries for old messages + recent messages intact\n    ```",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 117,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model_router",
                          "type": "ModelRouter"
                        },
                        {
                          "name": "neo4j_connector",
                          "type": "Neo4jConnector | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "config",
                          "type": "CompactionConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the ContextCompactor."
                    },
                    {
                      "name": "count_tokens",
                      "line": 136,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "text",
                          "type": "str"
                        }
                      ],
                      "return_type": "int",
                      "description": "Count tokens in a text string using tiktoken."
                    },
                    {
                      "name": "count_message_tokens",
                      "line": 150,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "messages",
                          "type": "list[Message]"
                        }
                      ],
                      "return_type": "int",
                      "description": "Count total tokens in a list of messages."
                    },
                    {
                      "name": "summarize",
                      "line": 172,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "messages",
                          "type": "list[Message]"
                        }
                      ],
                      "return_type": "str",
                      "description": "Summarize a list of messages using the LLM."
                    },
                    {
                      "name": "compact",
                      "line": 219,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "messages",
                          "type": "list[Message]"
                        },
                        {
                          "name": "max_tokens",
                          "type": "int | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "conversation_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "list[Message]",
                      "description": "Compact conversation history to fit within token limit."
                    },
                    {
                      "name": "store_summary",
                      "line": 324,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "summary",
                          "type": "str"
                        },
                        {
                          "name": "conversation_id",
                          "type": "str"
                        },
                        {
                          "name": "metadata",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "str",
                      "description": "Store a summary in Neo4j graph."
                    },
                    {
                      "name": "retrieve_relevant",
                      "line": 363,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "query",
                          "type": "str"
                        },
                        {
                          "name": "limit",
                          "type": "int",
                          "default": "5",
                          "optional": true
                        }
                      ],
                      "return_type": "list[dict[str, Any]]",
                      "description": "Retrieve relevant summaries from Neo4j."
                    },
                    {
                      "name": "retrieve_by_conversation",
                      "line": 405,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "conversation_id",
                          "type": "str"
                        },
                        {
                          "name": "limit",
                          "type": "int",
                          "default": "10",
                          "optional": true
                        }
                      ],
                      "return_type": "list[dict[str, Any]]",
                      "description": "Retrieve summaries for a specific conversation."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "tiktoken"
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.memory.neo4j",
                  "names": [
                    "Neo4jConnector"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "CompactionConfig",
                "ContextCompactor",
                "Message",
                "Summary"
              ]
            }
          ]
        },
        "memory": {
          "name": "memory",
          "path": "src/daw_agents/memory",
          "description": "",
          "modules": [
            {
              "name": "neo4j.py",
              "path": "daw_agents/memory/neo4j.py",
              "description": "Neo4j connector module providing a singleton pattern for managing Neo4j connections.",
              "classes": [
                {
                  "name": "Neo4jConfig",
                  "line": 21,
                  "description": "Configuration for Neo4j connection.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "uri",
                      "line": 24,
                      "type": "str"
                    },
                    {
                      "name": "user",
                      "line": 25,
                      "type": "str"
                    },
                    {
                      "name": "password",
                      "line": 26,
                      "type": "str"
                    },
                    {
                      "name": "database",
                      "line": 27,
                      "type": "str"
                    },
                    {
                      "name": "max_connection_pool_size",
                      "line": 28,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "Neo4jConnector",
                  "line": 33,
                  "description": "Singleton class for managing Neo4j connections and graph operations.\n\nThis class provides:\n- Connection pool management via singleton pattern\n- Basic graph operations (create node, create relationship, query)\n- Health check functionality\n- Graceful shutdown\n\nExample:\n    config = Neo4jConfig(password=\"your_password\")\n    connector = Neo4jConnector.get_instance(config)\n    node_id = await connector.create_node([\"Person\"], {\"name\": \"Alice\"})\n    await connector.close()",
                  "methods": [
                    {
                      "name": "__new__",
                      "line": 54,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "Neo4jConnector",
                      "description": "Prevent direct instantiation - use get_instance()."
                    },
                    {
                      "name": "get_instance",
                      "line": 59,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "config",
                          "type": "Neo4jConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "Neo4jConnector",
                      "description": "Get or create the singleton instance."
                    },
                    {
                      "name": "config",
                      "line": 93,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "Neo4jConfig",
                      "description": "Get the current configuration."
                    },
                    {
                      "name": "database",
                      "line": 100,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "str",
                      "description": "Get the database name."
                    },
                    {
                      "name": "create_node",
                      "line": 104,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "labels",
                          "type": "list[str]"
                        },
                        {
                          "name": "properties",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "str",
                      "description": "Create a node in the graph and return its element_id."
                    },
                    {
                      "name": "create_relationship",
                      "line": 135,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "from_node_id",
                          "type": "str"
                        },
                        {
                          "name": "to_node_id",
                          "type": "str"
                        },
                        {
                          "name": "rel_type",
                          "type": "str"
                        },
                        {
                          "name": "properties",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "str",
                      "description": "Create a relationship between two nodes."
                    },
                    {
                      "name": "query",
                      "line": 179,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "cypher",
                          "type": "str"
                        },
                        {
                          "name": "params",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "list[dict[str, Any]]",
                      "description": "Execute a Cypher query and return results."
                    },
                    {
                      "name": "get_node_by_id",
                      "line": 202,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "node_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "dict[str, Any] | None",
                      "description": "Retrieve a node by its element ID."
                    },
                    {
                      "name": "is_connected",
                      "line": 229,
                      "visibility": "public",
                      "async": true,
                      "return_type": "bool",
                      "description": "Check if the database connection is healthy."
                    },
                    {
                      "name": "close",
                      "line": 246,
                      "visibility": "public",
                      "async": true,
                      "return_type": "None",
                      "description": "Close the driver connection and reset the singleton."
                    }
                  ],
                  "properties": [
                    {
                      "name": "_instance",
                      "line": 50,
                      "type": "ClassVar[Neo4jConnector | None]"
                    },
                    {
                      "name": "_driver",
                      "line": 51,
                      "type": "ClassVar[Any | None]"
                    },
                    {
                      "name": "_config",
                      "line": 52,
                      "type": "ClassVar[Neo4jConfig | None]"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "Any",
                    "ClassVar"
                  ],
                  "is_relative": false
                },
                {
                  "module": "neo4j",
                  "names": [
                    "AsyncGraphDatabase"
                  ],
                  "is_relative": false
                },
                {
                  "module": "neo4j.exceptions",
                  "names": [
                    "Neo4jError"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "Neo4jConfig",
                "Neo4jConnector"
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/memory/__init__.py",
              "description": "Memory module for DAW Agents.",
              "imports": [
                {
                  "module": "daw_agents.memory.neo4j",
                  "names": [
                    "Neo4jConfig",
                    "Neo4jConnector"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "Neo4jConfig",
                "Neo4jConnector"
              ]
            }
          ]
        },
        "config": {
          "name": "config",
          "path": "src/daw_agents/config",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/config/__init__.py",
              "description": "Configuration modules for DAW agents.",
              "imports": [
                {
                  "module": "redis",
                  "names": [
                    "RedisConfig",
                    "get_async_redis_client",
                    "get_redis_client"
                  ],
                  "is_relative": true
                }
              ],
              "exports": [
                "RedisConfig",
                "get_redis_client",
                "get_async_redis_client"
              ]
            },
            {
              "name": "redis.py",
              "path": "daw_agents/config/redis.py",
              "description": "Redis configuration for dual-purpose: Celery broker + LangGraph checkpoints.",
              "classes": [
                {
                  "name": "RedisConfig",
                  "line": 29,
                  "description": "Redis connection configuration for dual-purpose use.\n\nThis dataclass manages Redis configuration for both:\n- Celery broker (message queue for background tasks)\n- LangGraph checkpoints (state persistence for agent workflows)\n\nAttributes:\n    host: Redis server hostname (default: localhost)\n    port: Redis server port (default: 6379)\n    password: Redis authentication password (default: None)\n    db_celery: Database number for Celery broker (default: 0)\n    db_langgraph: Database number for LangGraph checkpoints (default: 1)",
                  "decorators": [
                    "dataclass"
                  ],
                  "methods": [
                    {
                      "name": "__post_init__",
                      "line": 50,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Initialize values from environment if not provided."
                    },
                    {
                      "name": "celery_broker_url",
                      "line": 60,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "str",
                      "description": "Generate Celery broker connection URL."
                    },
                    {
                      "name": "langgraph_url",
                      "line": 75,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "str",
                      "description": "Generate LangGraph checkpoint connection URL."
                    }
                  ],
                  "properties": [
                    {
                      "name": "host",
                      "line": 44,
                      "type": "str"
                    },
                    {
                      "name": "port",
                      "line": 45,
                      "type": "int"
                    },
                    {
                      "name": "password",
                      "line": 46,
                      "type": "str | None"
                    },
                    {
                      "name": "db_celery",
                      "line": 47,
                      "type": "int"
                    },
                    {
                      "name": "db_langgraph",
                      "line": 48,
                      "type": "int"
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "get_redis_client",
                  "line": 90,
                  "description": "Get synchronous Redis client.",
                  "async": false,
                  "return_type": "Redis",
                  "parameters": [
                    {
                      "name": "db",
                      "type": "int",
                      "default": "0",
                      "optional": true
                    }
                  ]
                },
                {
                  "name": "get_async_redis_client",
                  "line": 121,
                  "description": "Get asynchronous Redis client.",
                  "async": true,
                  "return_type": "AsyncRedis",
                  "parameters": [
                    {
                      "name": "db",
                      "type": "int",
                      "default": "0",
                      "optional": true
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "os"
                },
                {
                  "module": "dataclasses",
                  "names": [
                    "dataclass"
                  ],
                  "is_relative": false
                },
                {
                  "module": "redis",
                  "names": [
                    "Redis"
                  ],
                  "is_relative": false
                },
                {
                  "module": "redis.asyncio",
                  "names": [
                    "Redis"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        },
        "auth": {
          "name": "auth",
          "path": "src/daw_agents/auth",
          "description": "",
          "modules": [
            {
              "name": "clerk.py",
              "path": "daw_agents/auth/clerk.py",
              "description": "Clerk JWT verification for FastAPI.",
              "classes": [
                {
                  "name": "ClerkConfig",
                  "line": 39,
                  "description": "Configuration for Clerk authentication.\n\nAttributes:\n    secret_key: Clerk secret key (CLERK_SECRET_KEY env var)\n    publishable_key: Clerk publishable key (CLERK_PUBLISHABLE_KEY env var)\n    jwks_url: URL to Clerk's JWKS endpoint\n    authorized_parties: List of allowed azp (authorized party) values\n    jwks_cache_ttl: TTL in seconds for JWKS cache (default: 300 = 5 minutes)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "secret_key",
                      "line": 50,
                      "type": "str"
                    },
                    {
                      "name": "publishable_key",
                      "line": 51,
                      "type": "str"
                    },
                    {
                      "name": "jwks_url",
                      "line": 52,
                      "type": "str"
                    },
                    {
                      "name": "authorized_parties",
                      "line": 53,
                      "type": "list[str]"
                    },
                    {
                      "name": "jwks_cache_ttl",
                      "line": 54,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "ClerkUser",
                  "line": 57,
                  "description": "Authenticated user from Clerk JWT.\n\nAttributes:\n    user_id: Clerk user ID (from 'sub' claim)\n    email: User's email address (optional)\n    name: User's display name (optional)\n    claims: All JWT claims for advanced use cases",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "user_id",
                      "line": 67,
                      "type": "str"
                    },
                    {
                      "name": "email",
                      "line": 68,
                      "type": "str | None"
                    },
                    {
                      "name": "name",
                      "line": 69,
                      "type": "str | None"
                    },
                    {
                      "name": "claims",
                      "line": 70,
                      "type": "dict[str, Any]"
                    }
                  ]
                },
                {
                  "name": "ClerkJWTVerifier",
                  "line": 73,
                  "description": "Verifies Clerk JWT tokens against JWKS.\n\nThis class handles:\n- Fetching and caching JWKS from Clerk\n- JWT signature verification using RS256\n- Standard claim validation (exp, nbf)\n- Authorized party (azp) validation\n- User extraction from verified tokens",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 84,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "ClerkConfig"
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the JWT verifier."
                    },
                    {
                      "name": "verify_token",
                      "line": 94,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "token",
                          "type": "str"
                        }
                      ],
                      "return_type": "ClerkUser",
                      "description": "Verify a JWT token and extract user information."
                    },
                    {
                      "name": "_get_jwks",
                      "line": 161,
                      "visibility": "protected",
                      "async": true,
                      "return_type": "dict[str, Any]",
                      "description": "Get JWKS from cache or fetch from Clerk."
                    },
                    {
                      "name": "_fetch_jwks",
                      "line": 184,
                      "visibility": "protected",
                      "async": true,
                      "return_type": "dict[str, Any]",
                      "description": "Fetch JWKS from Clerk endpoint."
                    },
                    {
                      "name": "_find_key_by_kid",
                      "line": 208,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "jwks",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "kid",
                          "type": "str"
                        }
                      ],
                      "return_type": "Any",
                      "description": "Find a key in JWKS by key ID."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "base64"
                },
                {
                  "module": "time"
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "httpx"
                },
                {
                  "module": "jwt"
                },
                {
                  "module": "cryptography.hazmat.backends",
                  "names": [
                    "default_backend"
                  ],
                  "is_relative": false
                },
                {
                  "module": "cryptography.hazmat.primitives.asymmetric.rsa",
                  "names": [
                    "RSAPublicNumbers"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.exceptions",
                  "names": [
                    "InvalidTokenError",
                    "JWKSFetchError",
                    "KeyNotFoundError",
                    "TokenExpiredError",
                    "UnauthorizedPartyError"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/auth/__init__.py",
              "description": "Clerk Authentication module for DAW Backend.",
              "imports": [
                {
                  "module": "daw_agents.auth.clerk",
                  "names": [
                    "ClerkConfig",
                    "ClerkJWTVerifier",
                    "ClerkUser"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.dependencies",
                  "names": [
                    "get_current_user",
                    "optional_current_user"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.exceptions",
                  "names": [
                    "AuthenticationError",
                    "InvalidTokenError",
                    "JWKSFetchError",
                    "KeyNotFoundError",
                    "MissingTokenError",
                    "TokenExpiredError",
                    "UnauthorizedPartyError"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.middleware",
                  "names": [
                    "ClerkAuthMiddleware"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "ClerkConfig",
                "ClerkUser",
                "ClerkJWTVerifier",
                "ClerkAuthMiddleware",
                "get_current_user",
                "optional_current_user",
                "AuthenticationError",
                "InvalidTokenError",
                "TokenExpiredError",
                "UnauthorizedPartyError",
                "MissingTokenError",
                "JWKSFetchError",
                "KeyNotFoundError"
              ]
            },
            {
              "name": "exceptions.py",
              "path": "daw_agents/auth/exceptions.py",
              "description": "Custom exceptions for Clerk authentication.",
              "classes": [
                {
                  "name": "AuthenticationError",
                  "line": 9,
                  "description": "Base exception for all authentication errors.",
                  "bases": [
                    "Exception"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 12,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str",
                          "default": "'Authentication failed'",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "TokenExpiredError",
                  "line": 17,
                  "description": "Raised when a JWT token has expired.",
                  "bases": [
                    "AuthenticationError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 20,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str",
                          "default": "'Token has expired'",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "InvalidTokenError",
                  "line": 24,
                  "description": "Raised when a JWT token is invalid (malformed, wrong signature, etc.).",
                  "bases": [
                    "AuthenticationError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 27,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str",
                          "default": "'Invalid token'",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "UnauthorizedPartyError",
                  "line": 31,
                  "description": "Raised when the azp (authorized party) claim doesn't match allowed origins.",
                  "bases": [
                    "AuthenticationError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 34,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str",
                          "default": "'Token not authorized for this application'",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "MissingTokenError",
                  "line": 40,
                  "description": "Raised when no authentication token is provided.",
                  "bases": [
                    "AuthenticationError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 43,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str",
                          "default": "'Authentication token required'",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "JWKSFetchError",
                  "line": 47,
                  "description": "Raised when JWKS endpoint cannot be reached or returns invalid data.",
                  "bases": [
                    "AuthenticationError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 50,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str",
                          "default": "'Failed to fetch JWKS'",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "KeyNotFoundError",
                  "line": 54,
                  "description": "Raised when the key ID (kid) from JWT is not found in JWKS.",
                  "bases": [
                    "AuthenticationError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 57,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str",
                          "default": "'Signing key not found in JWKS'",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                }
              ]
            },
            {
              "name": "middleware.py",
              "path": "daw_agents/auth/middleware.py",
              "description": "FastAPI middleware for Clerk authentication.",
              "classes": [
                {
                  "name": "ClerkAuthMiddleware",
                  "line": 22,
                  "description": "FastAPI middleware for Clerk JWT authentication.\n\nThis middleware:\n- Validates Authorization header format (Bearer <token>)\n- Verifies JWT tokens against Clerk JWKS\n- Stores verified user in request state for access by route handlers\n- Returns 401 for missing/invalid tokens\n- Supports excluding specific paths from authentication\n\nUsage:\n    config = ClerkConfig(...)\n    app.add_middleware(\n        ClerkAuthMiddleware,\n        config=config,\n        exclude_paths=[\"/health\", \"/docs\"]\n    )",
                  "bases": [
                    "BaseHTTPMiddleware"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 41,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "app",
                          "type": "Any"
                        },
                        {
                          "name": "config",
                          "type": "ClerkConfig"
                        },
                        {
                          "name": "exclude_paths",
                          "type": "list[str] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the middleware."
                    },
                    {
                      "name": "dispatch",
                      "line": 58,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "request",
                          "type": "Request"
                        },
                        {
                          "name": "call_next",
                          "type": "Callable[[Request], Any]"
                        }
                      ],
                      "return_type": "Response",
                      "description": "Process the request and validate authentication."
                    },
                    {
                      "name": "_is_excluded_path",
                      "line": 105,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if path should be excluded from authentication."
                    },
                    {
                      "name": "_unauthorized_response",
                      "line": 119,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "detail",
                          "type": "str"
                        }
                      ],
                      "return_type": "JSONResponse",
                      "description": "Create a 401 Unauthorized response."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "collections.abc",
                  "names": [
                    "Callable"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "fastapi",
                  "names": [
                    "Request",
                    "Response"
                  ],
                  "is_relative": false
                },
                {
                  "module": "starlette.middleware.base",
                  "names": [
                    "BaseHTTPMiddleware"
                  ],
                  "is_relative": false
                },
                {
                  "module": "starlette.responses",
                  "names": [
                    "JSONResponse"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.clerk",
                  "names": [
                    "ClerkConfig",
                    "ClerkJWTVerifier"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.exceptions",
                  "names": [
                    "AuthenticationError",
                    "TokenExpiredError"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "dependencies.py",
              "path": "daw_agents/auth/dependencies.py",
              "description": "FastAPI dependencies for Clerk authentication.",
              "functions": [
                {
                  "name": "get_current_user",
                  "line": 28,
                  "description": "Create a FastAPI dependency that returns the current authenticated user.",
                  "async": false,
                  "return_type": "Callable[..., Any]",
                  "parameters": [
                    {
                      "name": "config",
                      "type": "ClerkConfig"
                    }
                  ]
                },
                {
                  "name": "optional_current_user",
                  "line": 84,
                  "description": "Create a FastAPI dependency that optionally returns the current user.",
                  "async": false,
                  "return_type": "Callable[..., Any]",
                  "parameters": [
                    {
                      "name": "config",
                      "type": "ClerkConfig"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "collections.abc",
                  "names": [
                    "Callable"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any",
                    "cast"
                  ],
                  "is_relative": false
                },
                {
                  "module": "fastapi",
                  "names": [
                    "Depends",
                    "HTTPException",
                    "status"
                  ],
                  "is_relative": false
                },
                {
                  "module": "fastapi.security",
                  "names": [
                    "HTTPAuthorizationCredentials",
                    "HTTPBearer"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.clerk",
                  "names": [
                    "ClerkConfig",
                    "ClerkJWTVerifier",
                    "ClerkUser"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.exceptions",
                  "names": [
                    "AuthenticationError"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        },
        "deploy": {
          "name": "deploy",
          "path": "src/daw_agents/deploy",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/deploy/__init__.py",
              "description": "Deploy module for policy-as-code deployment gates.",
              "imports": [
                {
                  "module": "daw_agents.deploy.gates",
                  "names": [
                    "CodeQualityMetrics",
                    "DeploymentGateResult",
                    "DeploymentGates",
                    "GateConfig",
                    "GateResult",
                    "GateStatus",
                    "PerformanceMetrics",
                    "PolicyConfig",
                    "SecurityMetrics",
                    "UATMetrics"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "CodeQualityMetrics",
                "DeploymentGateResult",
                "DeploymentGates",
                "GateConfig",
                "GateResult",
                "GateStatus",
                "PerformanceMetrics",
                "PolicyConfig",
                "SecurityMetrics",
                "UATMetrics"
              ]
            },
            {
              "name": "gates.py",
              "path": "daw_agents/deploy/gates.py",
              "description": "Policy-as-Code Deployment Gates implementation.",
              "classes": [
                {
                  "name": "GateResult",
                  "line": 54,
                  "description": "Result from evaluating a single deployment gate.\n\nAttributes:\n    gate_name: Name of the gate (e.g., 'code_quality', 'security')\n    status: Evaluation result (PASS, WARN, BLOCK)\n    message: Human-readable explanation of the result\n    details: Optional dict with detailed metrics/findings",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "is_blocking",
                      "line": 70,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "bool",
                      "description": "Check if this gate result is blocking deployment."
                    }
                  ],
                  "properties": [
                    {
                      "name": "gate_name",
                      "line": 64,
                      "type": "str"
                    },
                    {
                      "name": "status",
                      "line": 65,
                      "type": "GateStatus"
                    },
                    {
                      "name": "message",
                      "line": 66,
                      "type": "str"
                    },
                    {
                      "name": "details",
                      "line": 67,
                      "type": "dict[str, Any] | None"
                    }
                  ]
                },
                {
                  "name": "DeploymentGateResult",
                  "line": 75,
                  "description": "Aggregate result from all deployment gates.\n\nAttributes:\n    environment: Target deployment environment (dev/staging/production)\n    gate_results: List of individual gate results",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "overall_status",
                      "line": 87,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "GateStatus",
                      "description": "Compute overall status from all gate results."
                    },
                    {
                      "name": "can_deploy",
                      "line": 99,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "bool",
                      "description": "Check if deployment can proceed."
                    },
                    {
                      "name": "get_blocking_gates",
                      "line": 106,
                      "visibility": "public",
                      "async": false,
                      "return_type": "list[GateResult]",
                      "description": "Get list of gates that are blocking deployment."
                    }
                  ],
                  "properties": [
                    {
                      "name": "environment",
                      "line": 83,
                      "type": "str"
                    },
                    {
                      "name": "gate_results",
                      "line": 84,
                      "type": "list[GateResult]"
                    }
                  ]
                },
                {
                  "name": "GateConfig",
                  "line": 116,
                  "description": "Configuration for a single deployment gate.\n\nAttributes:\n    enabled: Whether this gate is enabled\n    blocking: Whether failures block deployment\n    thresholds: Dict of threshold values for this gate",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "enabled",
                      "line": 125,
                      "type": "bool"
                    },
                    {
                      "name": "blocking",
                      "line": 126,
                      "type": "bool"
                    },
                    {
                      "name": "thresholds",
                      "line": 127,
                      "type": "dict[str, Any]"
                    }
                  ]
                },
                {
                  "name": "PolicyConfig",
                  "line": 130,
                  "description": "Policy configuration loaded from YAML.\n\nAttributes:\n    gates: Dict of gate name -> GateConfig\n    environments: Optional environment-specific overrides",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "from_yaml",
                      "line": 142,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "yaml_content",
                          "type": "str"
                        }
                      ],
                      "return_type": "PolicyConfig",
                      "description": "Parse PolicyConfig from YAML string."
                    },
                    {
                      "name": "from_file",
                      "line": 166,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "PolicyConfig",
                      "description": "Load PolicyConfig from YAML file."
                    },
                    {
                      "name": "get_environment_config",
                      "line": 178,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "environment",
                          "type": "str"
                        }
                      ],
                      "return_type": "PolicyConfig",
                      "description": "Get config with environment-specific overrides applied."
                    },
                    {
                      "name": "is_gate_enabled",
                      "line": 208,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "gate_name",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if a gate is enabled."
                    }
                  ],
                  "properties": [
                    {
                      "name": "gates",
                      "line": 138,
                      "type": "dict[str, GateConfig]"
                    },
                    {
                      "name": "environments",
                      "line": 139,
                      "type": "dict[str, dict[str, Any]]"
                    }
                  ]
                },
                {
                  "name": "CodeQualityMetrics",
                  "line": 226,
                  "description": "Metrics for code quality gate evaluation.\n\nAttributes:\n    coverage_new_code: Test coverage % for new code (0-100)\n    coverage_total: Total test coverage % (0-100)\n    typescript_strict: Whether TypeScript strict mode is enabled\n    linting_errors: Count of linting errors",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "coverage_new_code",
                      "line": 236,
                      "type": "float"
                    },
                    {
                      "name": "coverage_total",
                      "line": 237,
                      "type": "float"
                    },
                    {
                      "name": "typescript_strict",
                      "line": 238,
                      "type": "bool"
                    },
                    {
                      "name": "linting_errors",
                      "line": 239,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "SecurityMetrics",
                  "line": 242,
                  "description": "Metrics for security gate evaluation.\n\nAttributes:\n    sast_critical: Count of critical SAST findings\n    sast_high: Count of high severity SAST findings\n    sast_medium: Count of medium severity SAST findings\n    sca_critical: Count of critical SCA CVEs\n    sca_high: Count of high severity SCA CVEs\n    secrets_detected: Count of detected secrets",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "sast_critical",
                      "line": 254,
                      "type": "int"
                    },
                    {
                      "name": "sast_high",
                      "line": 255,
                      "type": "int"
                    },
                    {
                      "name": "sast_medium",
                      "line": 256,
                      "type": "int"
                    },
                    {
                      "name": "sca_critical",
                      "line": 257,
                      "type": "int"
                    },
                    {
                      "name": "sca_high",
                      "line": 258,
                      "type": "int"
                    },
                    {
                      "name": "secrets_detected",
                      "line": 259,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "PerformanceMetrics",
                  "line": 262,
                  "description": "Metrics for performance gate evaluation.\n\nAttributes:\n    api_p95_ms: API response time p95 in milliseconds\n    api_p99_ms: API response time p99 in milliseconds\n    bundle_size_bytes: Total bundle size in bytes\n    bundle_size_increase_percent: Bundle size increase from baseline (%)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "api_p95_ms",
                      "line": 272,
                      "type": "float"
                    },
                    {
                      "name": "api_p99_ms",
                      "line": 273,
                      "type": "float"
                    },
                    {
                      "name": "bundle_size_bytes",
                      "line": 274,
                      "type": "int"
                    },
                    {
                      "name": "bundle_size_increase_percent",
                      "line": 275,
                      "type": "float"
                    }
                  ]
                },
                {
                  "name": "UATMetrics",
                  "line": 278,
                  "description": "Metrics for UAT gate evaluation.\n\nAttributes:\n    p0_journeys_total: Total number of P0 user journeys\n    p0_journeys_passed: Number of P0 journeys that passed\n    p1_journeys_total: Total number of P1 user journeys\n    p1_journeys_passed: Number of P1 journeys that passed\n    visual_regression_percent: Visual regression difference (%)",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "p0_pass_rate",
                      "line": 296,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "float",
                      "description": "Calculate P0 journey pass rate."
                    }
                  ],
                  "properties": [
                    {
                      "name": "p0_journeys_total",
                      "line": 289,
                      "type": "int"
                    },
                    {
                      "name": "p0_journeys_passed",
                      "line": 290,
                      "type": "int"
                    },
                    {
                      "name": "p1_journeys_total",
                      "line": 291,
                      "type": "int"
                    },
                    {
                      "name": "p1_journeys_passed",
                      "line": 292,
                      "type": "int"
                    },
                    {
                      "name": "visual_regression_percent",
                      "line": 293,
                      "type": "float"
                    }
                  ]
                },
                {
                  "name": "DeploymentGates",
                  "line": 350,
                  "description": "Policy-as-code deployment gates evaluator.\n\nEvaluates deployment readiness against configured policy gates.\nEach gate checks specific metrics against thresholds and returns\na PASS, WARN, or BLOCK status.\n\nExample:\n    gates = DeploymentGates()\n    result = gates.evaluate_all(\n        environment=\"production\",\n        code_quality=CodeQualityMetrics(coverage_new_code=85.0, ...),\n        security=SecurityMetrics(sast_critical=0, ...),\n        ...\n    )\n    if result.can_deploy:\n        deploy()",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 369,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "PolicyConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize DeploymentGates with policy configuration."
                    },
                    {
                      "name": "_get_threshold",
                      "line": 380,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "gate_name",
                          "type": "str"
                        },
                        {
                          "name": "threshold_name",
                          "type": "str"
                        },
                        {
                          "name": "default",
                          "type": "Any"
                        }
                      ],
                      "return_type": "Any",
                      "description": "Get threshold value from config with default fallback."
                    },
                    {
                      "name": "evaluate_code_quality",
                      "line": 398,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "CodeQualityMetrics"
                        }
                      ],
                      "return_type": "GateResult",
                      "description": "Evaluate code quality gate."
                    },
                    {
                      "name": "evaluate_security",
                      "line": 468,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "SecurityMetrics"
                        }
                      ],
                      "return_type": "GateResult",
                      "description": "Evaluate security gate."
                    },
                    {
                      "name": "evaluate_performance",
                      "line": 541,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "PerformanceMetrics"
                        }
                      ],
                      "return_type": "GateResult",
                      "description": "Evaluate performance gate (WARNING only, not blocking)."
                    },
                    {
                      "name": "evaluate_uat",
                      "line": 595,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "UATMetrics"
                        },
                        {
                          "name": "environment",
                          "type": "str",
                          "default": "'staging'",
                          "optional": true
                        }
                      ],
                      "return_type": "GateResult",
                      "description": "Evaluate UAT gate."
                    },
                    {
                      "name": "evaluate_all",
                      "line": 661,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "environment",
                          "type": "str"
                        },
                        {
                          "name": "code_quality",
                          "type": "CodeQualityMetrics"
                        },
                        {
                          "name": "security",
                          "type": "SecurityMetrics"
                        },
                        {
                          "name": "performance",
                          "type": "PerformanceMetrics"
                        },
                        {
                          "name": "uat",
                          "type": "UATMetrics"
                        }
                      ],
                      "return_type": "DeploymentGateResult",
                      "description": "Evaluate all deployment gates."
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "GateStatus",
                  "kind": "enum",
                  "line": 35,
                  "description": "Status of a deployment gate evaluation.\n\nValues:\n    PASS: Gate passed, deployment can proceed\n    WARN: Gate has warnings but deployment can proceed\n    BLOCK: Gate failed, deployment is blocked",
                  "members": [
                    {
                      "name": "PASS",
                      "value": "pass"
                    },
                    {
                      "name": "WARN",
                      "value": "warn"
                    },
                    {
                      "name": "BLOCK",
                      "value": "block"
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "DEFAULT_POLICY_YAML",
                  "line": 308,
                  "value": "\ngates:\n  code_quality:\n    enabled: true\n    blocking: true\n    thresholds:\n      coverage_new_code: 80\n      coverage_total: 70\n      linting_errors: 0\n      typescript_strict: true\n  security:\n    enabled: true\n    blocking: true\n    thresholds:\n      sast_critical: 0\n      sca_critical: 0\n      secrets_detected: 0\n  performance:\n    enabled: true\n    blocking: false\n    thresholds:\n      api_p95_ms: 500\n      bundle_size_increase_percent: 10\n  uat:\n    enabled: true\n    blocking: false\n    thresholds:\n      p0_pass_rate: 100\n      visual_regression: 0.1\nenvironments:\n  production:\n    gates:\n      uat:\n        blocking: true\n",
                  "type": "str"
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "copy",
                  "names": [
                    "deepcopy"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pathlib",
                  "names": [
                    "Path"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "yaml"
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        },
        "agents": {
          "name": "agents",
          "path": "src/daw_agents/agents",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/agents/__init__.py",
              "description": ""
            },
            {
              "name": "models.py",
              "path": "daw_agents/agents/developer/models.py",
              "description": "Pydantic models for the Developer Agent.",
              "classes": [
                {
                  "name": "TestRunResult",
                  "line": 40,
                  "description": "Result of running tests in the sandbox.\n\nAttributes:\n    passed: Whether all tests passed\n    output: Full output from test execution\n    exit_code: Exit code from the test runner\n    duration_ms: Time taken to run tests in milliseconds\n    error: Error message if test execution failed",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "passed",
                      "line": 51,
                      "type": "bool"
                    },
                    {
                      "name": "output",
                      "line": 52,
                      "type": "str"
                    },
                    {
                      "name": "exit_code",
                      "line": 53,
                      "type": "int"
                    },
                    {
                      "name": "duration_ms",
                      "line": 54,
                      "type": "float"
                    },
                    {
                      "name": "error",
                      "line": 55,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "DeveloperResult",
                  "line": 58,
                  "description": "Final result of the Developer Agent workflow.\n\nAttributes:\n    success: Whether the development task completed successfully\n    source_file: Path to the source file that was created/modified\n    test_file: Path to the test file that was created\n    source_code: Final source code content\n    test_code: Final test code content\n    iterations: Number of TDD iterations performed\n    status: Final workflow status\n    error: Error message if workflow failed",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "success",
                      "line": 72,
                      "type": "bool"
                    },
                    {
                      "name": "source_file",
                      "line": 73,
                      "type": "str"
                    },
                    {
                      "name": "test_file",
                      "line": 74,
                      "type": "str"
                    },
                    {
                      "name": "source_code",
                      "line": 75,
                      "type": "str"
                    },
                    {
                      "name": "test_code",
                      "line": 76,
                      "type": "str"
                    },
                    {
                      "name": "iterations",
                      "line": 77,
                      "type": "int"
                    },
                    {
                      "name": "status",
                      "line": 78,
                      "type": "str"
                    },
                    {
                      "name": "error",
                      "line": 79,
                      "type": "str | None"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "DeveloperStatus",
                  "kind": "enum",
                  "line": 20,
                  "description": "Status enum for Developer Agent workflow states.\n\nThe Developer follows the TDD cycle:\n- WRITE_TEST: First write a failing test (start of RED phase)\n- RUN_TEST: Execute tests to verify pass/fail status\n- WRITE_CODE: Write implementation to pass tests (GREEN phase)\n- REFACTOR: Improve code quality while maintaining tests\n- COMPLETE: Workflow completed successfully\n- ERROR: Workflow encountered an unrecoverable error",
                  "members": [
                    {
                      "name": "WRITE_TEST",
                      "value": "write_test"
                    },
                    {
                      "name": "RUN_TEST",
                      "value": "run_test"
                    },
                    {
                      "name": "WRITE_CODE",
                      "value": "write_code"
                    },
                    {
                      "name": "REFACTOR",
                      "value": "refactor"
                    },
                    {
                      "name": "COMPLETE",
                      "value": "complete"
                    },
                    {
                      "name": "ERROR",
                      "value": "error"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "graph.py",
              "path": "daw_agents/agents/developer/graph.py",
              "description": "Developer Agent implementation using LangGraph.",
              "classes": [
                {
                  "name": "Developer",
                  "line": 58,
                  "description": "Developer Agent for TDD-driven code generation.\n\nThe Developer Agent implements the Red-Green-Refactor TDD workflow:\n1. Write a failing test (RED)\n2. Write minimal code to pass (GREEN)\n3. Refactor for quality (REFACTOR)\n\nThe agent uses ModelRouter with TaskType.CODING to ensure it uses\na coding-optimized model (Claude Sonnet, GPT-4o, etc.).\n\nAttributes:\n    router: ModelRouter instance for LLM calls\n    task_type: Always TaskType.CODING for developer tasks\n    max_iterations: Maximum TDD iterations to prevent infinite loops\n    graph: Compiled LangGraph workflow\n    mcp_client: Optional MCP client for tool integration\n    sandbox: Optional E2B sandbox for test execution\n    tdd_guard: Optional TDD guard for workflow enforcement\n\nExample:\n    developer = Developer()\n    result = await developer.execute(\n        task=\"Create a function to add two numbers\",\n        source_file=\"src/calculator.py\",\n        test_file=\"tests/test_calculator.py\"\n    )\n    if result.success:\n        print(f\"Generated code:\\n{result.source_code}\")",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 89,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "router",
                          "type": "ModelRouter | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "max_iterations",
                          "type": "int",
                          "default": "5",
                          "optional": true
                        },
                        {
                          "name": "mcp_client",
                          "type": "MCPClient | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "sandbox",
                          "type": "E2BSandbox | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "tdd_guard",
                          "type": "TDDGuard | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the Developer Agent."
                    },
                    {
                      "name": "_build_graph",
                      "line": 120,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "Any",
                      "description": "Build the LangGraph TDD workflow."
                    },
                    {
                      "name": "configure_mcp",
                      "line": 179,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "mcp_client",
                          "type": "MCPClient"
                        }
                      ],
                      "return_type": "None",
                      "description": "Configure MCP client for tool integration."
                    },
                    {
                      "name": "configure_sandbox",
                      "line": 188,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "sandbox",
                          "type": "E2BSandbox"
                        }
                      ],
                      "return_type": "None",
                      "description": "Configure E2B sandbox for test execution."
                    },
                    {
                      "name": "configure_tdd_guard",
                      "line": 197,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tdd_guard",
                          "type": "TDDGuard"
                        }
                      ],
                      "return_type": "None",
                      "description": "Configure TDD guard for workflow enforcement."
                    },
                    {
                      "name": "execute",
                      "line": 206,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "task",
                          "type": "str"
                        },
                        {
                          "name": "source_file",
                          "type": "str"
                        },
                        {
                          "name": "test_file",
                          "type": "str"
                        }
                      ],
                      "return_type": "DeveloperResult",
                      "description": "Execute the TDD workflow for a given task."
                    },
                    {
                      "name": "generate_test",
                      "line": 271,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "task",
                          "type": "str"
                        },
                        {
                          "name": "source_file",
                          "type": "str"
                        },
                        {
                          "name": "test_file",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Generate a test file for the given task."
                    },
                    {
                      "name": "generate_implementation",
                      "line": 298,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "task",
                          "type": "str"
                        },
                        {
                          "name": "test_code",
                          "type": "str"
                        },
                        {
                          "name": "source_file",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Generate implementation code for the given test."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING",
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "langgraph.graph",
                  "names": [
                    "END",
                    "START",
                    "StateGraph"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.developer.models",
                  "names": [
                    "DeveloperResult"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.developer.nodes",
                  "names": [
                    "refactor_node",
                    "route_after_refactor",
                    "route_after_run_test",
                    "route_after_write_test",
                    "run_test_node",
                    "write_code_node",
                    "write_test_node"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.developer.state",
                  "names": [
                    "DeveloperState"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.client",
                  "names": [
                    "MCPClient"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.sandbox.e2b",
                  "names": [
                    "E2BSandbox"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.tdd.guard",
                  "names": [
                    "TDDGuard"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/agents/developer/__init__.py",
              "description": "Developer Agent package for TDD-driven code generation.",
              "imports": [
                {
                  "module": "daw_agents.agents.developer.graph",
                  "names": [
                    "Developer"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.developer.models",
                  "names": [
                    "DeveloperResult",
                    "DeveloperStatus",
                    "TestRunResult"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.developer.state",
                  "names": [
                    "DeveloperState"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "Developer",
                "DeveloperResult",
                "DeveloperState",
                "DeveloperStatus",
                "TestRunResult"
              ]
            },
            {
              "name": "nodes.py",
              "path": "daw_agents/agents/developer/nodes.py",
              "description": "Node functions for the Developer Agent LangGraph workflow.",
              "functions": [
                {
                  "name": "generate_test_code",
                  "line": 37,
                  "description": "Generate test code from task description using LLM.",
                  "async": true,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "task_description",
                      "type": "str"
                    },
                    {
                      "name": "source_file",
                      "type": "str"
                    },
                    {
                      "name": "test_file",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "execute_tests_in_sandbox",
                  "line": 60,
                  "description": "Execute tests in E2B sandbox.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "test_code",
                      "type": "str"
                    },
                    {
                      "name": "source_code",
                      "type": "str"
                    },
                    {
                      "name": "test_file",
                      "type": "str"
                    },
                    {
                      "name": "source_file",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "generate_source_code",
                  "line": 89,
                  "description": "Generate source code to pass the tests using LLM.",
                  "async": true,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "task_description",
                      "type": "str"
                    },
                    {
                      "name": "test_code",
                      "type": "str"
                    },
                    {
                      "name": "test_result",
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "current_source",
                      "type": "str"
                    },
                    {
                      "name": "source_file",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "refactor_code",
                  "line": 115,
                  "description": "Refactor source code while maintaining passing tests.",
                  "async": true,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "source_code",
                      "type": "str"
                    },
                    {
                      "name": "test_code",
                      "type": "str"
                    },
                    {
                      "name": "task_description",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "write_test_node",
                  "line": 142,
                  "description": "Generate a failing test from the task description.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "DeveloperState"
                    }
                  ]
                },
                {
                  "name": "run_test_node",
                  "line": 168,
                  "description": "Execute tests in the E2B sandbox.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "DeveloperState"
                    }
                  ]
                },
                {
                  "name": "write_code_node",
                  "line": 196,
                  "description": "Generate implementation code to pass the tests.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "DeveloperState"
                    }
                  ]
                },
                {
                  "name": "refactor_node",
                  "line": 223,
                  "description": "Refactor code while maintaining passing tests.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "DeveloperState"
                    }
                  ]
                },
                {
                  "name": "route_after_write_test",
                  "line": 253,
                  "description": "Route after write_test node.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "DeveloperState"
                    }
                  ]
                },
                {
                  "name": "route_after_run_test",
                  "line": 267,
                  "description": "Route after run_test node based on test results.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "DeveloperState"
                    }
                  ]
                },
                {
                  "name": "route_after_refactor",
                  "line": 302,
                  "description": "Route after refactor node.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "DeveloperState"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.developer.state",
                  "names": [
                    "DeveloperState"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "state.py",
              "path": "daw_agents/agents/developer/state.py",
              "description": "Developer state definition for Developer Agent.",
              "types": [
                {
                  "name": "DeveloperState",
                  "kind": "typed_dict",
                  "line": 26,
                  "description": "State schema for the Developer Agent LangGraph workflow.\n\nAttributes:\n    task_description: The programming task to implement\n    source_file: Path to the source file to create/modify\n    test_file: Path to the test file to create/modify\n    source_code: Current source code content\n    test_code: Current test code content\n    status: Current workflow status (write_test, run_test, write_code, refactor, complete, error)\n    test_result: Result from the last test execution (None if not yet run)\n    iteration: Current iteration count in the TDD loop\n    max_iterations: Maximum allowed iterations to prevent infinite loops\n    error: Error message if workflow fails (None if no error)",
                  "members": [
                    {
                      "name": "task_description",
                      "type": "str"
                    },
                    {
                      "name": "source_file",
                      "type": "str"
                    },
                    {
                      "name": "test_file",
                      "type": "str"
                    },
                    {
                      "name": "source_code",
                      "type": "str"
                    },
                    {
                      "name": "test_code",
                      "type": "str"
                    },
                    {
                      "name": "status",
                      "type": "str"
                    },
                    {
                      "name": "test_result",
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "iteration",
                      "type": "int"
                    },
                    {
                      "name": "max_iterations",
                      "type": "int"
                    },
                    {
                      "name": "error",
                      "type": "str | None"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any",
                    "TypedDict"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "models.py",
              "path": "daw_agents/agents/validator/models.py",
              "description": "Pydantic models for Validator Agent.",
              "classes": [
                {
                  "name": "TestResult",
                  "line": 17,
                  "description": "Result from running test suite.\n\nAttributes:\n    passed: Whether all tests passed\n    total_tests: Total number of tests run\n    passed_tests: Number of tests that passed\n    failed_tests: Number of tests that failed\n    skipped_tests: Number of tests that were skipped\n    coverage_percent: Code coverage percentage (0-100)\n    failed_test_names: Names of tests that failed\n    output: Raw output from test runner",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "passed",
                      "line": 31,
                      "type": "bool"
                    },
                    {
                      "name": "total_tests",
                      "line": 32,
                      "type": "int"
                    },
                    {
                      "name": "passed_tests",
                      "line": 33,
                      "type": "int"
                    },
                    {
                      "name": "failed_tests",
                      "line": 34,
                      "type": "int"
                    },
                    {
                      "name": "skipped_tests",
                      "line": 35,
                      "type": "int"
                    },
                    {
                      "name": "coverage_percent",
                      "line": 36,
                      "type": "float"
                    },
                    {
                      "name": "failed_test_names",
                      "line": 37,
                      "type": "list[str]"
                    },
                    {
                      "name": "output",
                      "line": 38,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "SecurityFinding",
                  "line": 41,
                  "description": "Individual security vulnerability finding.\n\nAttributes:\n    severity: Severity level (critical, high, medium, low)\n    rule_id: Identifier for the security rule that was triggered\n    message: Human-readable description of the finding\n    file_path: Path to the file containing the vulnerability\n    line_number: Line number where the vulnerability was found",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "severity",
                      "line": 52,
                      "type": "Literal['critical', 'high', 'medium', 'low']"
                    },
                    {
                      "name": "rule_id",
                      "line": 53,
                      "type": "str"
                    },
                    {
                      "name": "message",
                      "line": 54,
                      "type": "str"
                    },
                    {
                      "name": "file_path",
                      "line": 55,
                      "type": "str"
                    },
                    {
                      "name": "line_number",
                      "line": 56,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "StyleIssue",
                  "line": 59,
                  "description": "Code style/linting issue.\n\nAttributes:\n    rule_id: Linting rule identifier (e.g., E501, W503)\n    message: Description of the style issue\n    file_path: Path to the file with the issue\n    line_number: Line number of the issue\n    fixable: Whether the issue can be auto-fixed",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "rule_id",
                      "line": 70,
                      "type": "str"
                    },
                    {
                      "name": "message",
                      "line": 71,
                      "type": "str"
                    },
                    {
                      "name": "file_path",
                      "line": 72,
                      "type": "str"
                    },
                    {
                      "name": "line_number",
                      "line": 73,
                      "type": "int"
                    },
                    {
                      "name": "fixable",
                      "line": 74,
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "ValidationResult",
                  "line": 77,
                  "description": "Final validation result for code review.\n\nAttributes:\n    status: Validation outcome (approved, rejected, retry)\n    passed_tests: Whether all tests passed\n    passed_security: Whether security scan passed\n    passed_style: Whether style checks passed\n    feedback: Human-readable summary of validation\n    suggestions: List of actionable improvement suggestions\n    test_result: Detailed test results (optional)\n    security_findings: List of security findings (optional)\n    style_issues: List of style issues (optional)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "status",
                      "line": 92,
                      "type": "Literal['approved', 'rejected', 'retry']"
                    },
                    {
                      "name": "passed_tests",
                      "line": 93,
                      "type": "bool"
                    },
                    {
                      "name": "passed_security",
                      "line": 94,
                      "type": "bool"
                    },
                    {
                      "name": "passed_style",
                      "line": 95,
                      "type": "bool"
                    },
                    {
                      "name": "feedback",
                      "line": 96,
                      "type": "str"
                    },
                    {
                      "name": "suggestions",
                      "line": 97,
                      "type": "list[str]"
                    },
                    {
                      "name": "test_result",
                      "line": 98,
                      "type": "TestResult | None"
                    },
                    {
                      "name": "security_findings",
                      "line": 99,
                      "type": "list[SecurityFinding]"
                    },
                    {
                      "name": "style_issues",
                      "line": 100,
                      "type": "list[StyleIssue]"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Literal"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/agents/validator/__init__.py",
              "description": "Validator Agent module (VALIDATOR-001, VALIDATOR-002).",
              "imports": [
                {
                  "module": "daw_agents.agents.validator.agent",
                  "names": [
                    "ValidatorAgent"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.validator.ensemble",
                  "names": [
                    "ConsensusStatus",
                    "EnsembleConfig",
                    "EnsembleResult",
                    "ModelVote",
                    "ValidationEnsemble",
                    "ValidationType",
                    "VotingStrategy"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.validator.models",
                  "names": [
                    "SecurityFinding",
                    "StyleIssue",
                    "TestResult",
                    "ValidationResult"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.validator.state",
                  "names": [
                    "ValidationState"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "ValidatorAgent",
                "ValidationResult",
                "ValidationState",
                "SecurityFinding",
                "StyleIssue",
                "TestResult",
                "ValidationEnsemble",
                "EnsembleConfig",
                "EnsembleResult",
                "ModelVote",
                "VotingStrategy",
                "ValidationType",
                "ConsensusStatus"
              ]
            },
            {
              "name": "ensemble.py",
              "path": "daw_agents/agents/validator/ensemble.py",
              "description": "Multi-Model Validation Ensemble for VALIDATOR-002.",
              "classes": [
                {
                  "name": "ModelVote",
                  "line": 82,
                  "description": "Individual model's validation result.\n\nRepresents a single model's vote in the ensemble validation.\nIncludes the model's decision, confidence, and reasoning.\n\nAttributes:\n    model_id: Identifier of the model that produced this vote\n    passed: Whether the model believes the code passes validation\n    confidence: Confidence score (0.0 to 1.0)\n    reasoning: Explanation for the decision\n    issues_found: List of issues identified by the model\n    validation_time_ms: Time taken for validation in milliseconds\n    tokens_used: Number of tokens used for the validation",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "model_id",
                      "line": 98,
                      "type": "str"
                    },
                    {
                      "name": "passed",
                      "line": 99,
                      "type": "bool"
                    },
                    {
                      "name": "confidence",
                      "line": 100,
                      "type": "float"
                    },
                    {
                      "name": "reasoning",
                      "line": 101,
                      "type": "str"
                    },
                    {
                      "name": "issues_found",
                      "line": 102,
                      "type": "list[str]"
                    },
                    {
                      "name": "validation_time_ms",
                      "line": 103,
                      "type": "int"
                    },
                    {
                      "name": "tokens_used",
                      "line": 104,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "EnsembleConfig",
                  "line": 107,
                  "description": "Configuration for validation ensemble.\n\nControls how the ensemble operates including which models to use,\nvoting strategy, and thresholds.\n\nAttributes:\n    models: List of model identifiers to use (minimum 2)\n    voting_strategy: How to aggregate votes (majority, unanimous, weighted)\n    threshold: Pass threshold for majority voting (default 0.5)\n    model_weights: Weights for weighted voting (optional)\n    require_ensemble_for: Which validation types require ensemble\n    min_confidence: Minimum confidence to avoid human review",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "validate_minimum_models",
                      "line": 135,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "field_validator",
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "v",
                          "type": "list[str]"
                        }
                      ],
                      "return_type": "list[str]",
                      "description": "Ensure at least 2 models are specified for ensemble."
                    }
                  ],
                  "properties": [
                    {
                      "name": "models",
                      "line": 122,
                      "type": "list[str]"
                    },
                    {
                      "name": "voting_strategy",
                      "line": 125,
                      "type": "VotingStrategy"
                    },
                    {
                      "name": "threshold",
                      "line": 126,
                      "type": "float"
                    },
                    {
                      "name": "model_weights",
                      "line": 127,
                      "type": "dict[str, float]"
                    },
                    {
                      "name": "require_ensemble_for",
                      "line": 128,
                      "type": "list[ValidationType]"
                    },
                    {
                      "name": "min_confidence",
                      "line": 131,
                      "type": "float"
                    }
                  ]
                },
                {
                  "name": "EnsembleResult",
                  "line": 142,
                  "description": "Aggregated result from ensemble validation.\n\nContains the consensus decision, all individual votes, and metadata\nabout the validation process.\n\nAttributes:\n    consensus_status: Overall consensus status\n    final_decision: Final pass/fail decision\n    votes: List of individual model votes\n    consensus_confidence: Aggregated confidence score\n    reasoning: Explanation of the consensus decision\n    aggregated_issues: Deduplicated list of all issues found\n    requires_human_review: Whether human review is needed",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "consensus_status",
                      "line": 158,
                      "type": "ConsensusStatus"
                    },
                    {
                      "name": "final_decision",
                      "line": 159,
                      "type": "bool"
                    },
                    {
                      "name": "votes",
                      "line": 160,
                      "type": "list[ModelVote]"
                    },
                    {
                      "name": "consensus_confidence",
                      "line": 161,
                      "type": "float"
                    },
                    {
                      "name": "reasoning",
                      "line": 162,
                      "type": "str"
                    },
                    {
                      "name": "aggregated_issues",
                      "line": 163,
                      "type": "list[str]"
                    },
                    {
                      "name": "requires_human_review",
                      "line": 164,
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "ValidationEnsemble",
                  "line": 167,
                  "description": "Multi-model validation ensemble for critical validations.\n\nThe ValidationEnsemble runs validation through multiple LLM models\nand aggregates their results using a configurable consensus mechanism.\nThis ensures higher quality validation by leveraging diverse model\nperspectives and avoiding single-model blind spots.\n\nExample:\n    ```python\n    from daw_agents.agents.validator.ensemble import (\n        ValidationEnsemble,\n        EnsembleConfig,\n    )\n    from daw_agents.models.router import ModelRouter\n\n    router = ModelRouter()\n    config = EnsembleConfig(\n        models=[\"gpt-4o\", \"claude-3-5-sonnet-20241022\"],\n        voting_strategy=VotingStrategy.MAJORITY,\n    )\n    ensemble = ValidationEnsemble(model_router=router, config=config)\n\n    result = await ensemble.validate_with_ensemble(\n        code=\"def hello(): return 'hello'\",\n        tests=\"def test_hello(): assert hello() == 'hello'\",\n        policies=[\"security\", \"style\"],\n    )\n\n    if result.final_decision:\n        print(\"Code passed ensemble validation!\")\n    else:\n        print(f\"Issues: {result.aggregated_issues}\")\n    ```\n\nAttributes:\n    model_router: Router for LLM model selection\n    config: Ensemble configuration",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 207,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model_router",
                          "type": "Any"
                        },
                        {
                          "name": "config",
                          "type": "EnsembleConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the ValidationEnsemble."
                    },
                    {
                      "name": "validate_with_ensemble",
                      "line": 227,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "code",
                          "type": "str"
                        },
                        {
                          "name": "tests",
                          "type": "str"
                        },
                        {
                          "name": "policies",
                          "type": "list[str]"
                        }
                      ],
                      "return_type": "EnsembleResult",
                      "description": "Run validation through multiple models and aggregate results."
                    },
                    {
                      "name": "_validate_with_model",
                      "line": 270,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "model_id",
                          "type": "str"
                        },
                        {
                          "name": "code",
                          "type": "str"
                        },
                        {
                          "name": "tests",
                          "type": "str"
                        },
                        {
                          "name": "policies",
                          "type": "list[str]"
                        }
                      ],
                      "return_type": "ModelVote",
                      "description": "Run validation using a specific model."
                    },
                    {
                      "name": "_build_validation_prompt",
                      "line": 341,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "code",
                          "type": "str"
                        },
                        {
                          "name": "tests",
                          "type": "str"
                        },
                        {
                          "name": "policies",
                          "type": "list[str]"
                        }
                      ],
                      "return_type": "str",
                      "description": "Build the validation prompt for LLM models."
                    },
                    {
                      "name": "_parse_model_response",
                      "line": 388,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model_id",
                          "type": "str"
                        },
                        {
                          "name": "response",
                          "type": "str"
                        }
                      ],
                      "return_type": "ModelVote",
                      "description": "Parse the model's response into a ModelVote."
                    },
                    {
                      "name": "aggregate_votes",
                      "line": 423,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "votes",
                          "type": "list[ModelVote]"
                        }
                      ],
                      "return_type": "EnsembleResult",
                      "description": "Aggregate individual model votes into ensemble result."
                    },
                    {
                      "name": "determine_consensus",
                      "line": 493,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "votes",
                          "type": "list[ModelVote]"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Determine the final consensus decision based on voting strategy."
                    },
                    {
                      "name": "_majority_vote",
                      "line": 514,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "votes",
                          "type": "list[ModelVote]"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Apply majority voting strategy."
                    },
                    {
                      "name": "_unanimous_vote",
                      "line": 527,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "votes",
                          "type": "list[ModelVote]"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Apply unanimous voting strategy."
                    },
                    {
                      "name": "_weighted_vote",
                      "line": 538,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "votes",
                          "type": "list[ModelVote]"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Apply weighted voting strategy."
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "VotingStrategy",
                  "kind": "enum",
                  "line": 43,
                  "description": "Voting strategies for ensemble consensus.\n\n- MAJORITY: More than 50% must agree (default)\n- UNANIMOUS: All models must agree\n- WEIGHTED: Models have different weights in voting",
                  "members": [
                    {
                      "name": "MAJORITY",
                      "value": "majority"
                    },
                    {
                      "name": "UNANIMOUS",
                      "value": "unanimous"
                    },
                    {
                      "name": "WEIGHTED",
                      "value": "weighted"
                    }
                  ]
                },
                {
                  "name": "ValidationType",
                  "kind": "enum",
                  "line": 56,
                  "description": "Types of validation that may require ensemble.\n\n- STANDARD: Normal validation, ensemble optional\n- SECURITY: Security-critical validation, ensemble recommended\n- PRODUCTION: Production deployment, ensemble required",
                  "members": [
                    {
                      "name": "STANDARD",
                      "value": "standard"
                    },
                    {
                      "name": "SECURITY",
                      "value": "security"
                    },
                    {
                      "name": "PRODUCTION",
                      "value": "production"
                    }
                  ]
                },
                {
                  "name": "ConsensusStatus",
                  "kind": "enum",
                  "line": 69,
                  "description": "Status of consensus among models.\n\n- CONSENSUS_PASS: All/majority models agree code passes\n- CONSENSUS_FAIL: All/majority models agree code fails\n- SPLIT: Models disagree (requires human review)",
                  "members": [
                    {
                      "name": "CONSENSUS_PASS",
                      "value": "consensus_pass"
                    },
                    {
                      "name": "CONSENSUS_FAIL",
                      "value": "consensus_fail"
                    },
                    {
                      "name": "SPLIT",
                      "value": "split"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "asyncio"
                },
                {
                  "module": "json"
                },
                {
                  "module": "logging"
                },
                {
                  "module": "re"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field",
                    "field_validator"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "ValidationEnsemble",
                "EnsembleConfig",
                "EnsembleResult",
                "ModelVote",
                "VotingStrategy",
                "ValidationType",
                "ConsensusStatus"
              ]
            },
            {
              "name": "agent.py",
              "path": "daw_agents/agents/validator/agent.py",
              "description": "Validator Agent implementation using LangGraph.",
              "classes": [
                {
                  "name": "ValidatorAgent",
                  "line": 43,
                  "description": "Validator Agent for code review and validation.\n\nThe ValidatorAgent implements a multi-step validation workflow:\n1. Run tests and collect results\n2. Run security scanning\n3. Check code style/policy\n4. Generate validation report\n5. Route decision (approve/retry/escalate)\n\nThe agent uses ModelRouter with TaskType.VALIDATION to ensure\ncross-validation with a different model than the Executor.\n\nAttributes:\n    router: ModelRouter instance for LLM calls\n    task_type: Always TaskType.VALIDATION for cross-validation\n    max_retries: Maximum retry attempts for fixable issues\n    graph: Compiled LangGraph workflow\n    mcp_client: Optional MCP client for tool integration\n\nExample:\n    agent = ValidatorAgent()\n    result = await agent.validate(\n        code=\"def hello(): return 'world'\",\n        requirements=\"Function should return 'world'\"\n    )\n    if result.status == \"approved\":\n        print(\"Code validated successfully!\")",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 73,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "router",
                          "type": "ModelRouter | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "max_retries",
                          "type": "int",
                          "default": "3",
                          "optional": true
                        },
                        {
                          "name": "mcp_client",
                          "type": "MCPClient | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the ValidatorAgent."
                    },
                    {
                      "name": "_build_graph",
                      "line": 97,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "Any",
                      "description": "Build the LangGraph validation workflow."
                    },
                    {
                      "name": "configure_mcp",
                      "line": 136,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "mcp_client",
                          "type": "MCPClient"
                        }
                      ],
                      "return_type": "None",
                      "description": "Configure MCP client for tool integration."
                    },
                    {
                      "name": "validate",
                      "line": 145,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "code",
                          "type": "str"
                        },
                        {
                          "name": "requirements",
                          "type": "str"
                        }
                      ],
                      "return_type": "ValidationResult",
                      "description": "Validate code against requirements."
                    },
                    {
                      "name": "check_security",
                      "line": 196,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "code",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[dict[str, Any]]",
                      "description": "Run security scan only."
                    },
                    {
                      "name": "check_style",
                      "line": 213,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "code",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[dict[str, Any]]",
                      "description": "Run style check only."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "langgraph.graph",
                  "names": [
                    "END",
                    "START",
                    "StateGraph"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.validator.models",
                  "names": [
                    "ValidationResult"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.validator.nodes",
                  "names": [
                    "generate_report_node",
                    "policy_check_node",
                    "route_decision",
                    "run_tests_node",
                    "security_scan_node"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.validator.state",
                  "names": [
                    "ValidationState"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.client",
                  "names": [
                    "MCPClient"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "nodes.py",
              "path": "daw_agents/agents/validator/nodes.py",
              "description": "Node functions for Validator Agent LangGraph workflow.",
              "functions": [
                {
                  "name": "run_pytest",
                  "line": 24,
                  "description": "Execute pytest and return results.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "code",
                      "type": "str"
                    },
                    {
                      "name": "requirements",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "run_security_scan",
                  "line": 53,
                  "description": "Run SAST security scanning on code.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "code",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "run_linter",
                  "line": 75,
                  "description": "Run code linting/style checks.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "code",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "run_tests_node",
                  "line": 97,
                  "description": "Execute test suite and update state with results.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "ValidationState"
                    }
                  ]
                },
                {
                  "name": "security_scan_node",
                  "line": 127,
                  "description": "Run security scanning and update state with findings.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "ValidationState"
                    }
                  ]
                },
                {
                  "name": "policy_check_node",
                  "line": 154,
                  "description": "Run policy/style checks and update state with issues.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "ValidationState"
                    }
                  ]
                },
                {
                  "name": "generate_report_node",
                  "line": 181,
                  "description": "Generate final validation report based on all checks.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "ValidationState"
                    }
                  ]
                },
                {
                  "name": "route_decision",
                  "line": 262,
                  "description": "Determine the next step based on validation results.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "ValidationState"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.validator.state",
                  "names": [
                    "ValidationState"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "state.py",
              "path": "daw_agents/agents/validator/state.py",
              "description": "Validation state definition for Validator Agent.",
              "types": [
                {
                  "name": "ValidationState",
                  "kind": "typed_dict",
                  "line": 17,
                  "description": "State schema for the Validator Agent LangGraph workflow.\n\nAttributes:\n    code: The source code being validated\n    requirements: The requirements/specification to validate against\n    test_results: Results from running tests (None if not yet run)\n    security_findings: Security scan findings (None if not yet run)\n    style_issues: Code style/linting issues (None if not yet run)\n    validation_result: Final validation result (None until complete)\n    current_node: Current position in the workflow graph\n    retry_count: Number of retry attempts made\n    max_retries: Maximum allowed retry attempts",
                  "members": [
                    {
                      "name": "code",
                      "type": "str"
                    },
                    {
                      "name": "requirements",
                      "type": "str"
                    },
                    {
                      "name": "test_results",
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "security_findings",
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "style_issues",
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "validation_result",
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "current_node",
                      "type": "str"
                    },
                    {
                      "name": "retry_count",
                      "type": "int"
                    },
                    {
                      "name": "max_retries",
                      "type": "int"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any",
                    "TypedDict"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "personas.py",
              "path": "daw_agents/agents/planner/personas.py",
              "description": "Roundtable Personas for the Taskmaster Agent (PLANNER-002).",
              "classes": [
                {
                  "name": "PersonaConfig",
                  "line": 55,
                  "description": "Configuration for a synthetic persona.\n\nDefines the persona's identity, focus areas, and prompt template\nused for generating critiques.\n\nAttributes:\n    name: Short identifier for the persona (e.g., \"CTO\")\n    role: Full role title (e.g., \"Chief Technology Officer\")\n    critique_focus: List of areas this persona focuses on\n    prompt_template: Template string with {concept} placeholder\n    description: Optional description of the persona\n    system_prompt: Optional custom system prompt for the LLM",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "name",
                      "line": 70,
                      "type": "str"
                    },
                    {
                      "name": "role",
                      "line": 71,
                      "type": "str"
                    },
                    {
                      "name": "critique_focus",
                      "line": 72,
                      "type": "list[str]"
                    },
                    {
                      "name": "prompt_template",
                      "line": 75,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 78,
                      "type": "str | None"
                    },
                    {
                      "name": "system_prompt",
                      "line": 81,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "PersonaCritique",
                  "line": 86,
                  "description": "Structured critique output from a persona.\n\nRepresents the analysis and feedback from a single persona\non a concept or proposal.\n\nAttributes:\n    persona_name: Name of the persona providing the critique\n    concerns: List of concerns or issues identified\n    recommendations: List of actionable recommendations\n    questions: List of clarifying questions\n    severity: Overall severity level of concerns\n    summary: Brief summary of the critique",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "to_markdown",
                      "line": 116,
                      "visibility": "public",
                      "async": false,
                      "return_type": "str",
                      "description": "Convert critique to markdown format."
                    }
                  ],
                  "properties": [
                    {
                      "name": "persona_name",
                      "line": 101,
                      "type": "str"
                    },
                    {
                      "name": "concerns",
                      "line": 102,
                      "type": "list[str]"
                    },
                    {
                      "name": "recommendations",
                      "line": 105,
                      "type": "list[str]"
                    },
                    {
                      "name": "questions",
                      "line": 108,
                      "type": "list[str]"
                    },
                    {
                      "name": "severity",
                      "line": 111,
                      "type": "CritiqueSeverity"
                    },
                    {
                      "name": "summary",
                      "line": 114,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "SynthesizedFeedback",
                  "line": 144,
                  "description": "Synthesized feedback from multiple persona critiques.\n\nCombines and summarizes feedback from all personas into\na unified view.\n\nAttributes:\n    all_concerns: Combined list of all concerns\n    all_recommendations: Combined list of all recommendations\n    all_questions: Combined list of all questions\n    highest_severity: Highest severity among all critiques\n    combined_summary: Overall summary combining all feedback\n    persona_summaries: Dict mapping persona name to their summary",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "all_concerns",
                      "line": 159,
                      "type": "list[str]"
                    },
                    {
                      "name": "all_recommendations",
                      "line": 162,
                      "type": "list[str]"
                    },
                    {
                      "name": "all_questions",
                      "line": 165,
                      "type": "list[str]"
                    },
                    {
                      "name": "highest_severity",
                      "line": 168,
                      "type": "CritiqueSeverity"
                    },
                    {
                      "name": "combined_summary",
                      "line": 171,
                      "type": "str"
                    },
                    {
                      "name": "persona_summaries",
                      "line": 174,
                      "type": "dict[str, str]"
                    }
                  ]
                },
                {
                  "name": "PersonaRegistry",
                  "line": 283,
                  "description": "Registry for managing available personas.\n\nProvides methods to register, retrieve, and list personas.\nInitializes with default CTO, UX, and Security personas.",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 290,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Initialize registry with default personas."
                    },
                    {
                      "name": "register",
                      "line": 298,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "persona",
                          "type": "PersonaConfig"
                        }
                      ],
                      "return_type": "None",
                      "description": "Register a persona in the registry."
                    },
                    {
                      "name": "unregister",
                      "line": 307,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "name",
                          "type": "str"
                        }
                      ],
                      "return_type": "None",
                      "description": "Remove a persona from the registry."
                    },
                    {
                      "name": "get_persona",
                      "line": 318,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "name",
                          "type": "str"
                        }
                      ],
                      "return_type": "PersonaConfig | None",
                      "description": "Get a persona by name (case insensitive)."
                    },
                    {
                      "name": "list_personas",
                      "line": 329,
                      "visibility": "public",
                      "async": false,
                      "return_type": "list[str]",
                      "description": "List all registered persona names."
                    },
                    {
                      "name": "get_all",
                      "line": 337,
                      "visibility": "public",
                      "async": false,
                      "return_type": "list[PersonaConfig]",
                      "description": "Get all registered personas."
                    }
                  ]
                },
                {
                  "name": "RoundtableSession",
                  "line": 351,
                  "description": "Session manager for running roundtable discussions.\n\nOrchestrates critique collection from multiple personas\nand synthesizes their feedback.\n\nAttributes:\n    _model_router: Router for LLM calls\n    _registry: Registry of available personas",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 362,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model_router",
                          "type": "ModelRouter"
                        },
                        {
                          "name": "registry",
                          "type": "PersonaRegistry | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize a roundtable session."
                    },
                    {
                      "name": "get_persona",
                      "line": 376,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "name",
                          "type": "str"
                        }
                      ],
                      "return_type": "PersonaConfig | None",
                      "description": "Get a persona from the registry."
                    },
                    {
                      "name": "run_critique",
                      "line": 387,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "persona",
                          "type": "PersonaConfig"
                        },
                        {
                          "name": "concept",
                          "type": "str"
                        }
                      ],
                      "return_type": "PersonaCritique",
                      "description": "Run a critique with a single persona."
                    },
                    {
                      "name": "_extract_critique",
                      "line": 435,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "response",
                          "type": "str"
                        },
                        {
                          "name": "persona_name",
                          "type": "str"
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Extract critique data from LLM response."
                    },
                    {
                      "name": "_extract_json",
                      "line": 468,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "text",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Extract JSON from a text response that may contain markdown."
                    },
                    {
                      "name": "run_roundtable",
                      "line": 506,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "concept",
                          "type": "str"
                        },
                        {
                          "name": "persona_names",
                          "type": "list[str] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "list[PersonaCritique]",
                      "description": "Run a full roundtable with multiple personas."
                    },
                    {
                      "name": "synthesize_feedback",
                      "line": 560,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "critiques",
                          "type": "list[PersonaCritique]"
                        }
                      ],
                      "return_type": "SynthesizedFeedback",
                      "description": "Synthesize feedback from multiple critiques."
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "CritiqueSeverity",
                  "kind": "enum",
                  "line": 41,
                  "description": "Severity levels for critique concerns.",
                  "members": [
                    {
                      "name": "LOW",
                      "value": "low"
                    },
                    {
                      "name": "MEDIUM",
                      "value": "medium"
                    },
                    {
                      "name": "HIGH",
                      "value": "high"
                    },
                    {
                      "name": "CRITICAL",
                      "value": "critical"
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "CTO_PERSONA",
                  "line": 183
                },
                {
                  "name": "UX_PERSONA",
                  "line": 213
                },
                {
                  "name": "SECURITY_PERSONA",
                  "line": 243
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "json"
                },
                {
                  "module": "logging"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "CritiqueSeverity",
                "PersonaConfig",
                "PersonaCritique",
                "SynthesizedFeedback",
                "CTO_PERSONA",
                "UX_PERSONA",
                "SECURITY_PERSONA",
                "PersonaRegistry",
                "RoundtableSession"
              ]
            },
            {
              "name": "complexity_analyzer.py",
              "path": "daw_agents/agents/planner/complexity_analyzer.py",
              "description": "Complexity Analysis Engine for DAW Workbench.",
              "classes": [
                {
                  "name": "ComplexityScore",
                  "line": 81,
                  "description": "Represents the complexity score for a single feature.\n\nAttributes:\n    feature: Name of the feature\n    cognitive_load: Score from 1-10 (1=trivial, 10=extremely complex)\n    risk_rating: Overall risk level for this feature\n    description: Optional description of complexity factors",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "validate_cognitive_load",
                      "line": 102,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "field_validator",
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "v",
                          "type": "int"
                        }
                      ],
                      "return_type": "int",
                      "description": "Validate cognitive load is within bounds."
                    }
                  ],
                  "properties": [
                    {
                      "name": "feature",
                      "line": 91,
                      "type": "str"
                    },
                    {
                      "name": "cognitive_load",
                      "line": 92,
                      "type": "int"
                    },
                    {
                      "name": "risk_rating",
                      "line": 95,
                      "type": "RiskRating"
                    },
                    {
                      "name": "description",
                      "line": 96,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "DependencyNode",
                  "line": 109,
                  "description": "Represents a node in the dependency graph.\n\nAttributes:\n    id: Unique identifier for the node\n    name: Human-readable name\n    dependencies: List of node IDs this node depends on\n    dependents: List of node IDs that depend on this node\n    risk_rating: Risk level for this node",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 120,
                      "type": "str"
                    },
                    {
                      "name": "name",
                      "line": 121,
                      "type": "str"
                    },
                    {
                      "name": "dependencies",
                      "line": 122,
                      "type": "list[str]"
                    },
                    {
                      "name": "dependents",
                      "line": 125,
                      "type": "list[str]"
                    },
                    {
                      "name": "risk_rating",
                      "line": 128,
                      "type": "RiskRating"
                    }
                  ]
                },
                {
                  "name": "DependencyGraph",
                  "line": 133,
                  "description": "Represents the full dependency graph.\n\nAttributes:\n    nodes: List of all dependency nodes",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "get_node",
                      "line": 144,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "node_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "DependencyNode | None",
                      "description": "Get a node by its ID."
                    },
                    {
                      "name": "get_critical_nodes",
                      "line": 158,
                      "visibility": "public",
                      "async": false,
                      "return_type": "list[DependencyNode]",
                      "description": "Get all nodes with critical risk rating."
                    }
                  ],
                  "properties": [
                    {
                      "name": "nodes",
                      "line": 140,
                      "type": "list[DependencyNode]"
                    }
                  ]
                },
                {
                  "name": "ArchitecturalWarning",
                  "line": 167,
                  "description": "Represents a warning about architectural issues.\n\nAttributes:\n    warning_type: Type of warning (bottleneck, circular_dependency, etc.)\n    feature: The feature or component affected\n    description: Detailed description of the issue\n    severity: How severe the issue is\n    mitigation: Recommended mitigation strategy",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "warning_type",
                      "line": 178,
                      "type": "str"
                    },
                    {
                      "name": "feature",
                      "line": 179,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 180,
                      "type": "str"
                    },
                    {
                      "name": "severity",
                      "line": 181,
                      "type": "RiskRating"
                    },
                    {
                      "name": "mitigation",
                      "line": 182,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "ModelRecommendation",
                  "line": 185,
                  "description": "Recommends a model tier for a specific task.\n\nAttributes:\n    task_id: The task identifier\n    task_description: Description of the task\n    tier: Recommended model tier\n    recommended_model: Specific model recommendation\n    reasoning: Why this model was recommended",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "task_id",
                      "line": 196,
                      "type": "str"
                    },
                    {
                      "name": "task_description",
                      "line": 197,
                      "type": "str"
                    },
                    {
                      "name": "tier",
                      "line": 198,
                      "type": "ModelTier"
                    },
                    {
                      "name": "recommended_model",
                      "line": 199,
                      "type": "str"
                    },
                    {
                      "name": "reasoning",
                      "line": 200,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "ComplexityAnalysis",
                  "line": 203,
                  "description": "Complete complexity analysis output.\n\nThis is the main output structure that matches the required\ncomplexity_analysis.json format from FR-02.5.\n\nAttributes:\n    prd_title: Title of the analyzed PRD\n    features: List of feature complexity scores\n    dependency_graph: The dependency graph\n    model_recommendations: Model tier recommendations per task\n    bottleneck_warnings: List of architectural warnings",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "overall_cognitive_load",
                      "line": 232,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "float",
                      "description": "Calculate the average cognitive load across all features."
                    },
                    {
                      "name": "to_json",
                      "line": 242,
                      "visibility": "public",
                      "async": false,
                      "return_type": "str",
                      "description": "Serialize the analysis to JSON format."
                    }
                  ],
                  "properties": [
                    {
                      "name": "prd_title",
                      "line": 217,
                      "type": "str"
                    },
                    {
                      "name": "features",
                      "line": 218,
                      "type": "list[ComplexityScore]"
                    },
                    {
                      "name": "dependency_graph",
                      "line": 221,
                      "type": "DependencyGraph"
                    },
                    {
                      "name": "model_recommendations",
                      "line": 224,
                      "type": "list[ModelRecommendation]"
                    },
                    {
                      "name": "bottleneck_warnings",
                      "line": 227,
                      "type": "list[ArchitecturalWarning]"
                    }
                  ]
                },
                {
                  "name": "ComplexityAnalyzer",
                  "line": 319,
                  "description": "Analyzes PRD documents to produce complexity analysis.\n\nThe analyzer:\n1. Extracts features from PRD using LLM\n2. Calculates cognitive load per feature\n3. Builds dependency graph with risk ratings\n4. Recommends model tiers per task type\n5. Detects architectural bottlenecks\n\nIntegrates with:\n- MODEL-001 (ModelRouter) for LLM calls\n- CORE-003 (MCPClient) for optional codebase analysis\n\nExample:\n    ```python\n    analyzer = ComplexityAnalyzer()\n    analysis = await analyzer.analyze_prd(prd_content)\n    print(analysis.to_json())\n    ```",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 352,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model_router",
                          "type": "ModelRouter | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "mcp_client",
                          "type": "MCPClient | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the ComplexityAnalyzer."
                    },
                    {
                      "name": "analyze_prd",
                      "line": 366,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "prd",
                          "type": "str"
                        }
                      ],
                      "return_type": "ComplexityAnalysis",
                      "description": "Perform complete complexity analysis on a PRD."
                    },
                    {
                      "name": "_extract_title",
                      "line": 418,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "prd",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Extract the title from a PRD."
                    },
                    {
                      "name": "_extract_features",
                      "line": 437,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "prd",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[dict[str, Any]]",
                      "description": "Extract features from PRD using LLM."
                    },
                    {
                      "name": "_extract_json",
                      "line": 476,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "text",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Extract JSON from a text response."
                    },
                    {
                      "name": "_build_complexity_scores",
                      "line": 513,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "features_data",
                          "type": "list[dict[str, Any]]"
                        }
                      ],
                      "return_type": "list[ComplexityScore]",
                      "description": "Build ComplexityScore objects from feature data."
                    },
                    {
                      "name": "_parse_risk_rating",
                      "line": 550,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "risk_str",
                          "type": "str"
                        }
                      ],
                      "return_type": "RiskRating",
                      "description": "Parse a risk rating string to enum."
                    },
                    {
                      "name": "calculate_cognitive_load",
                      "line": 567,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "feature",
                          "type": "str"
                        }
                      ],
                      "return_type": "int",
                      "description": "Calculate cognitive load score for a single feature."
                    },
                    {
                      "name": "build_dependency_graph",
                      "line": 603,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "features",
                          "type": "list[dict[str, Any]]"
                        }
                      ],
                      "return_type": "DependencyGraph",
                      "description": "Build a dependency graph from feature list."
                    },
                    {
                      "name": "_to_node_id",
                      "line": 646,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "name",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Convert a feature name to a node ID."
                    },
                    {
                      "name": "_infer_tasks_from_features",
                      "line": 657,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "features",
                          "type": "list[dict[str, Any]]"
                        }
                      ],
                      "return_type": "list[dict[str, Any]]",
                      "description": "Infer tasks from features for model recommendations."
                    },
                    {
                      "name": "recommend_models",
                      "line": 692,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tasks",
                          "type": "list[dict[str, Any]]"
                        }
                      ],
                      "return_type": "list[ModelRecommendation]",
                      "description": "Generate model recommendations for a list of tasks."
                    },
                    {
                      "name": "detect_bottlenecks",
                      "line": 747,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "graph",
                          "type": "DependencyGraph"
                        }
                      ],
                      "return_type": "list[ArchitecturalWarning]",
                      "description": "Detect architectural bottlenecks in the dependency graph."
                    },
                    {
                      "name": "_get_bottleneck_mitigation",
                      "line": 808,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "node",
                          "type": "DependencyNode"
                        }
                      ],
                      "return_type": "str",
                      "description": "Get mitigation strategy for a bottleneck."
                    }
                  ],
                  "properties": [
                    {
                      "name": "TIER_MODEL_MAP",
                      "line": 345,
                      "type": "dict[ModelTier, str]"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "RiskRating",
                  "kind": "enum",
                  "line": 51,
                  "description": "Risk rating levels for features and dependencies.",
                  "members": [
                    {
                      "name": "LOW",
                      "value": "low"
                    },
                    {
                      "name": "MEDIUM",
                      "value": "medium"
                    },
                    {
                      "name": "HIGH",
                      "value": "high"
                    },
                    {
                      "name": "CRITICAL",
                      "value": "critical"
                    }
                  ]
                },
                {
                  "name": "ModelTier",
                  "kind": "enum",
                  "line": 60,
                  "description": "Model tiers for task routing.\n\nBased on MODEL-001 router configuration:\n- PLANNING: o1/Claude Opus for high reasoning tasks\n- CODING: Claude Sonnet/GPT-4o for implementation\n- VALIDATION: Different model for cross-validation\n- FAST: Claude Haiku/GPT-4o-mini for quick tasks",
                  "members": [
                    {
                      "name": "PLANNING",
                      "value": "planning"
                    },
                    {
                      "name": "CODING",
                      "value": "coding"
                    },
                    {
                      "name": "VALIDATION",
                      "value": "validation"
                    },
                    {
                      "name": "FAST",
                      "value": "fast"
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "FEATURE_EXTRACTION_PROMPT",
                  "line": 256,
                  "value": "Analyze this PRD and extract all features with their complexity.\n\nPRD:\n{prd}\n\nFor each feature, provide:\n1. name: Feature name\n2. cognitive_load: Score 1-10 (1=trivial, 10=extremely complex)\n3. risk: \"low\", \"medium\", \"high\", or \"critical\"\n4. dependencies: List of other features this depends on\n\nConsider these factors for cognitive load:\n- Technical complexity\n- Integration requirements\n- Security implications\n- Performance considerations\n- Error handling needs\n- State management complexity\n\nOutput JSON format:\n{{\n    \"features\": [\n        {{\n            \"name\": \"Feature Name\",\n            \"cognitive_load\": 7,\n            \"risk\": \"medium\",\n            \"dependencies\": [\"Other Feature\"]\n        }}\n    ]\n}}\n\nOutput ONLY valid JSON, no additional text.",
                  "type": "str"
                },
                {
                  "name": "COGNITIVE_LOAD_PROMPT",
                  "line": 290,
                  "value": "Analyze the cognitive load for implementing this feature:\n\nFeature: {feature}\n\nScore from 1-10 where:\n1-2: Trivial (simple CRUD, basic UI)\n3-4: Low (standard patterns, well-documented)\n5-6: Medium (some complexity, requires design)\n7-8: High (significant complexity, security/performance critical)\n9-10: Very High (novel algorithms, complex integrations)\n\nConsider:\n- Technical complexity\n- Integration requirements\n- Security implications\n- Error handling needs\n- Testing complexity\n\nOutput JSON:\n{{\"score\": 5, \"reasoning\": \"Brief explanation\"}}\n\nOutput ONLY valid JSON.",
                  "type": "str"
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "json"
                },
                {
                  "module": "logging"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field",
                    "field_validator"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.client",
                  "names": [
                    "MCPClient"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "ComplexityAnalyzer",
                "ComplexityAnalysis",
                "ComplexityScore",
                "DependencyGraph",
                "DependencyNode",
                "ArchitecturalWarning",
                "ModelRecommendation",
                "RiskRating",
                "ModelTier"
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/agents/planner/__init__.py",
              "description": "Planner agents for DAW Workbench.",
              "imports": [
                {
                  "module": "daw_agents.agents.planner.complexity_analyzer",
                  "names": [
                    "ArchitecturalWarning",
                    "ComplexityAnalysis",
                    "ComplexityAnalyzer",
                    "ComplexityScore",
                    "DependencyGraph",
                    "DependencyNode",
                    "ModelRecommendation",
                    "ModelTier",
                    "RiskRating"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.planner.personas",
                  "names": [
                    "CTO_PERSONA",
                    "SECURITY_PERSONA",
                    "UX_PERSONA",
                    "CritiqueSeverity",
                    "PersonaConfig",
                    "PersonaCritique",
                    "PersonaRegistry",
                    "RoundtableSession",
                    "SynthesizedFeedback"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.planner.prd_generator",
                  "names": [
                    "AcceptanceCriterion",
                    "NonFunctionalRequirement",
                    "NonFunctionalType",
                    "PRDGenerationConfig",
                    "PRDGenerator",
                    "PRDValidationError",
                    "PRDValidationResult",
                    "TechSpec",
                    "UserStoryPriority"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.planner.task_decomposer",
                  "names": [
                    "DecomposedTask",
                    "DecompositionResult",
                    "TaskDecomposer",
                    "TaskDecomposerConfig",
                    "TaskPriority",
                    "TaskType",
                    "TaskVerification",
                    "VerificationType"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.planner.taskmaster",
                  "names": [
                    "PlannerState",
                    "PlannerStatus",
                    "PRDOutput",
                    "RoundtablePersona",
                    "Task",
                    "Taskmaster"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "Taskmaster",
                "Task",
                "PRDOutput",
                "PlannerState",
                "PlannerStatus",
                "RoundtablePersona",
                "PRDGenerator",
                "PRDGenerationConfig",
                "PRDValidationResult",
                "PRDValidationError",
                "AcceptanceCriterion",
                "NonFunctionalRequirement",
                "TechSpec",
                "UserStoryPriority",
                "NonFunctionalType",
                "PersonaConfig",
                "PersonaCritique",
                "CritiqueSeverity",
                "SynthesizedFeedback",
                "PersonaRegistry",
                "RoundtableSession",
                "CTO_PERSONA",
                "UX_PERSONA",
                "SECURITY_PERSONA",
                "ComplexityAnalyzer",
                "ComplexityAnalysis",
                "ComplexityScore",
                "DependencyGraph",
                "DependencyNode",
                "ArchitecturalWarning",
                "ModelRecommendation",
                "RiskRating",
                "ModelTier",
                "TaskDecomposer",
                "TaskDecomposerConfig",
                "DecomposedTask",
                "DecompositionResult",
                "TaskVerification",
                "TaskPriority",
                "TaskType",
                "VerificationType"
              ]
            },
            {
              "name": "prd_generator.py",
              "path": "daw_agents/agents/planner/prd_generator.py",
              "description": "PRD Generator for enhanced PRD output (PRD-OUTPUT-001).",
              "classes": [
                {
                  "name": "PRDGenerationConfig",
                  "line": 58,
                  "description": "Configuration for PRD generation and validation.\n\nControls what elements are required for a complete PRD.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "require_p0_story",
                      "line": 64,
                      "type": "bool"
                    },
                    {
                      "name": "require_acceptance_criteria",
                      "line": 67,
                      "type": "bool"
                    },
                    {
                      "name": "require_tech_specs",
                      "line": 70,
                      "type": "bool"
                    },
                    {
                      "name": "require_nfr",
                      "line": 73,
                      "type": "bool"
                    },
                    {
                      "name": "min_user_stories",
                      "line": 76,
                      "type": "int"
                    },
                    {
                      "name": "min_acceptance_criteria_per_story",
                      "line": 79,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "PRDValidationResult",
                  "line": 84,
                  "description": "Result of PRD validation.\n\nContains validation status, errors, and warnings.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "is_valid",
                      "line": 90,
                      "type": "bool"
                    },
                    {
                      "name": "errors",
                      "line": 91,
                      "type": "list[str]"
                    },
                    {
                      "name": "warnings",
                      "line": 92,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "PRDValidationError",
                  "line": 95,
                  "description": "Exception raised when PRD validation fails.\n\nAttributes:\n    message: Error message\n    errors: List of specific validation errors",
                  "bases": [
                    "Exception"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 103,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str"
                        },
                        {
                          "name": "errors",
                          "type": "list[str] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize PRD validation error."
                    },
                    {
                      "name": "__str__",
                      "line": 114,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "str",
                      "description": "Return error message."
                    }
                  ]
                },
                {
                  "name": "PRDGenerator",
                  "line": 205,
                  "description": "Generates and validates structured PRD documents.\n\nThe PRDGenerator takes input from Taskmaster (basic PRDOutput)\nand enhances it into a fully-validated PRDSchema with:\n- User stories in proper format with priorities\n- Acceptance criteria in Given/When/Then format\n- Complete tech specs with architecture decisions\n- Non-functional requirements\n\nAttributes:\n    _model_router: Router for LLM model selection\n    _config: Configuration for generation and validation",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 220,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model_router",
                          "type": "ModelRouter | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "config",
                          "type": "PRDGenerationConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the PRD generator."
                    },
                    {
                      "name": "generate",
                      "line": 234,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "requirement",
                          "type": "str"
                        },
                        {
                          "name": "clarifications",
                          "type": "list[str] | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "roundtable_critiques",
                          "type": "list[str] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "PRDSchema",
                      "description": "Generate a complete PRD from requirements."
                    },
                    {
                      "name": "enhance_from_taskmaster",
                      "line": 299,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "taskmaster_output",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "clarifications",
                          "type": "list[str] | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "roundtable_critiques",
                          "type": "list[str] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "PRDSchema",
                      "description": "Enhance a Taskmaster PRDOutput into a complete PRDSchema."
                    },
                    {
                      "name": "_parse_prd_response",
                      "line": 362,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "data",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "PRDSchema",
                      "description": "Parse PRD response data into PRDSchema."
                    },
                    {
                      "name": "_extract_json",
                      "line": 464,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "text",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Extract JSON from a text response that may contain markdown."
                    },
                    {
                      "name": "validate_completeness",
                      "line": 501,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "prd",
                          "type": "PRDSchema"
                        }
                      ],
                      "return_type": "PRDValidationResult",
                      "description": "Validate that a PRD is complete and ready for task decomposition."
                    },
                    {
                      "name": "can_proceed_to_task_decomposition",
                      "line": 562,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "prd",
                          "type": "PRDSchema"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if PRD is complete enough to proceed to task decomposition."
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "PRD_ENHANCEMENT_PROMPT",
                  "line": 123,
                  "value": "You are an expert Product Manager enhancing a PRD.\n\nORIGINAL PRD:\n{original_prd}\n\nCLARIFICATIONS:\n{clarifications}\n\nROUNDTABLE FEEDBACK:\n{critiques}\n\nEnhance this PRD to a complete, structured format with the following:\n\n1. **User Stories**: Each story needs:\n   - Unique ID (US-XXX)\n   - Title\n   - Description in \"As a [user], I want [goal] so that [benefit]\" format\n   - Priority (P0=critical, P1=high, P2=medium)\n   - Acceptance criteria in Given/When/Then format\n\n2. **Tech Specs**: Include:\n   - Architecture pattern\n   - Key architecture decisions\n   - Technology stack\n   - Infrastructure requirements (if applicable)\n   - Constraints\n\n3. **Acceptance Criteria**: All criteria in Given/When/Then format:\n   - given: Precondition\n   - when: Action\n   - then: Expected result\n\n4. **Non-Functional Requirements**: At least consider:\n   - Performance (response times, throughput)\n   - Security (authentication, authorization)\n   - Scalability (if applicable)\n\nOutput ONLY valid JSON matching this structure:\n{{\n    \"title\": \"PRD Title\",\n    \"version\": \"1.0.0\",\n    \"overview\": \"Product overview\",\n    \"user_stories\": [\n        {{\n            \"id\": \"US-001\",\n            \"title\": \"Story Title\",\n            \"description\": \"As a user, I want...\",\n            \"priority\": \"P0\",\n            \"acceptance_criteria\": [\n                {{\"given\": \"...\", \"when\": \"...\", \"then\": \"...\"}}\n            ]\n        }}\n    ],\n    \"tech_specs\": {{\n        \"architecture_pattern\": \"...\",\n        \"architecture_decisions\": [\"...\"],\n        \"technology_stack\": [\"...\"],\n        \"infrastructure_requirements\": [\"...\"],\n        \"constraints\": [\"...\"]\n    }},\n    \"acceptance_criteria\": [\n        {{\"given\": \"...\", \"when\": \"...\", \"then\": \"...\"}}\n    ],\n    \"non_functional_requirements\": [\n        {{\n            \"type\": \"performance|security|scalability|reliability|maintainability|usability\",\n            \"description\": \"...\",\n            \"metric\": \"...\",\n            \"target\": \"...\",\n            \"priority\": \"P0|P1|P2\"\n        }}\n    ]\n}}\n\nEnsure at least one P0 user story with acceptance criteria.",
                  "type": "str"
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "json"
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.schemas.prd_schema",
                  "names": [
                    "AcceptanceCriteriaSchema",
                    "NonFunctionalRequirementSchema",
                    "NonFunctionalType",
                    "PRDSchema",
                    "TechSpecSchema",
                    "UserStoryPriority",
                    "UserStorySchema"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "PRDGenerator",
                "PRDGenerationConfig",
                "PRDValidationResult",
                "PRDValidationError",
                "AcceptanceCriterion",
                "NonFunctionalRequirement",
                "TechSpec",
                "UserStoryPriority",
                "NonFunctionalType"
              ]
            },
            {
              "name": "taskmaster.py",
              "path": "daw_agents/agents/planner/taskmaster.py",
              "description": "Taskmaster Agent - The Planner Agent for DAW Workbench.",
              "classes": [
                {
                  "name": "Task",
                  "line": 56,
                  "description": "Represents an atomic task to be executed.\n\nFollows the schema from tasks.json.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 62,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 63,
                      "type": "str"
                    },
                    {
                      "name": "priority",
                      "line": 64,
                      "type": "str"
                    },
                    {
                      "name": "type",
                      "line": 65,
                      "type": "str"
                    },
                    {
                      "name": "dependencies",
                      "line": 66,
                      "type": "list[str]"
                    },
                    {
                      "name": "estimated_hours",
                      "line": 69,
                      "type": "float | None"
                    },
                    {
                      "name": "model_hint",
                      "line": 72,
                      "type": "str | None"
                    },
                    {
                      "name": "verification",
                      "line": 75,
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "context_files",
                      "line": 78,
                      "type": "list[str] | None"
                    },
                    {
                      "name": "instruction",
                      "line": 81,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "UserStory",
                  "line": 86,
                  "description": "Represents a user story in the PRD.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 89,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 90,
                      "type": "str"
                    },
                    {
                      "name": "priority",
                      "line": 91,
                      "type": "str"
                    },
                    {
                      "name": "acceptance_criteria",
                      "line": 92,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "PRDOutput",
                  "line": 97,
                  "description": "Structured PRD output following the prd_generator schema.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "title",
                      "line": 100,
                      "type": "str"
                    },
                    {
                      "name": "overview",
                      "line": 101,
                      "type": "str"
                    },
                    {
                      "name": "user_stories",
                      "line": 102,
                      "type": "list[dict[str, Any]]"
                    },
                    {
                      "name": "tech_specs",
                      "line": 105,
                      "type": "dict[str, Any]"
                    },
                    {
                      "name": "acceptance_criteria",
                      "line": 108,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "RoundtablePersona",
                  "line": 113,
                  "description": "Represents a synthetic persona for roundtable discussion.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "name",
                      "line": 116,
                      "type": "str"
                    },
                    {
                      "name": "role",
                      "line": 117,
                      "type": "str"
                    },
                    {
                      "name": "focus",
                      "line": 118,
                      "type": "str"
                    },
                    {
                      "name": "critique_prompt",
                      "line": 119,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "Taskmaster",
                  "line": 290,
                  "description": "The Planner Agent that converts requirements into tasks.\n\nImplements a LangGraph workflow with states:\n1. INTERVIEW - Clarify user requirements\n2. ROUNDTABLE - Get critiques from synthetic personas\n3. GENERATE_PRD - Create structured PRD\n4. COMPLETE - Extract and prioritize tasks\n\nAttributes:\n    workflow: Compiled LangGraph workflow\n    _model_router: Model router for LLM selection\n    _mcp_client: MCP client for tool access\n    _neo4j: Neo4j connector for persistence",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 306,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model_router",
                          "type": "ModelRouter | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "mcp_client",
                          "type": "MCPClient | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "neo4j_connector",
                          "type": "Neo4jConnector | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "personas",
                          "type": "list[RoundtablePersona] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the Taskmaster agent."
                    },
                    {
                      "name": "_build_workflow",
                      "line": 329,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "Any",
                      "description": "Build the LangGraph state machine workflow."
                    },
                    {
                      "name": "_route_after_interview",
                      "line": 360,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "state",
                          "type": "PlannerState"
                        }
                      ],
                      "return_type": "str",
                      "description": "Route after interview based on whether we have enough clarifications."
                    },
                    {
                      "name": "_interview_node",
                      "line": 376,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "state",
                          "type": "PlannerState"
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Interview node: Ask clarifying questions."
                    },
                    {
                      "name": "_roundtable_node",
                      "line": 425,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "state",
                          "type": "PlannerState"
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Roundtable node: Collect critiques from synthetic personas."
                    },
                    {
                      "name": "_generate_prd_node",
                      "line": 471,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "state",
                          "type": "PlannerState"
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Generate PRD node: Create structured PRD from requirements."
                    },
                    {
                      "name": "_decompose_tasks_node",
                      "line": 531,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "state",
                          "type": "PlannerState"
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Decompose tasks node: Break PRD into atomic tasks."
                    },
                    {
                      "name": "_extract_json",
                      "line": 596,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "text",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Extract JSON from a text response that may contain markdown."
                    },
                    {
                      "name": "create_initial_state",
                      "line": 638,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "requirement",
                          "type": "str"
                        }
                      ],
                      "return_type": "PlannerState",
                      "description": "Create initial state for the workflow."
                    },
                    {
                      "name": "plan",
                      "line": 658,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "requirement",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[Task]",
                      "description": "Execute the full planning workflow."
                    },
                    {
                      "name": "get_personas",
                      "line": 685,
                      "visibility": "public",
                      "async": false,
                      "return_type": "list[RoundtablePersona]",
                      "description": "Get the configured roundtable personas."
                    },
                    {
                      "name": "prioritize",
                      "line": 693,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tasks",
                          "type": "list[Task]"
                        }
                      ],
                      "return_type": "list[Task]",
                      "description": "Order tasks by dependency and priority."
                    },
                    {
                      "name": "assign_metadata",
                      "line": 746,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task",
                          "type": "Task"
                        }
                      ],
                      "return_type": "Task",
                      "description": "Assign metadata to a task if not already set."
                    },
                    {
                      "name": "_get_next_status",
                      "line": 792,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "state",
                          "type": "PlannerState"
                        }
                      ],
                      "return_type": "PlannerStatus",
                      "description": "Determine the next status based on current state."
                    },
                    {
                      "name": "_persist_conversation",
                      "line": 819,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "state",
                          "type": "PlannerState"
                        }
                      ],
                      "return_type": "None",
                      "description": "Persist the conversation to Neo4j."
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "PlannerStatus",
                  "kind": "enum",
                  "line": 46,
                  "description": "Status values for the Planner state machine.",
                  "members": [
                    {
                      "name": "INTERVIEW",
                      "value": "interview"
                    },
                    {
                      "name": "ROUNDTABLE",
                      "value": "roundtable"
                    },
                    {
                      "name": "GENERATE_PRD",
                      "value": "generate_prd"
                    },
                    {
                      "name": "COMPLETE",
                      "value": "complete"
                    },
                    {
                      "name": "ERROR",
                      "value": "error"
                    }
                  ]
                },
                {
                  "name": "PlannerState",
                  "kind": "typed_dict",
                  "line": 122,
                  "description": "State for the Planner LangGraph workflow.\n\nThis TypedDict defines all fields maintained across nodes.",
                  "members": [
                    {
                      "name": "requirement",
                      "type": "str"
                    },
                    {
                      "name": "messages",
                      "type": "list[dict[str, str]]"
                    },
                    {
                      "name": "clarifications",
                      "type": "list[str]"
                    },
                    {
                      "name": "roundtable_critiques",
                      "type": "list[str]"
                    },
                    {
                      "name": "prd",
                      "type": "PRDOutput | None"
                    },
                    {
                      "name": "tasks",
                      "type": "list[Task]"
                    },
                    {
                      "name": "status",
                      "type": "PlannerStatus"
                    },
                    {
                      "name": "error",
                      "type": "str | None"
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "DEFAULT_PERSONAS",
                  "line": 142
                },
                {
                  "name": "INTERVIEW_PROMPT",
                  "line": 195,
                  "value": "You are an expert Product Manager conducting a requirements interview.\n\nUSER REQUIREMENT:\n{requirement}\n\nPREVIOUS CONVERSATION:\n{conversation}\n\nYour task is to ask clarifying questions to better understand the user's needs.\nFocus on:\n1. Target users and use cases\n2. Key features and priorities\n3. Technical constraints\n4. Timeline and budget considerations\n5. Integration requirements\n\nAsk 3-5 specific, targeted questions. Be professional and concise.",
                  "type": "str"
                },
                {
                  "name": "PRD_GENERATION_PROMPT",
                  "line": 213,
                  "value": "You are an expert Product Manager generating a structured PRD.\n\nORIGINAL REQUIREMENT:\n{requirement}\n\nCLARIFICATIONS FROM USER:\n{clarifications}\n\nROUNDTABLE FEEDBACK:\n{critiques}\n\nGenerate a complete PRD in JSON format with the following structure:\n{{\n    \"title\": \"PRD title\",\n    \"overview\": \"High-level product overview\",\n    \"user_stories\": [\n        {{\n            \"id\": \"US-001\",\n            \"description\": \"As a [user], I want [goal] so that [benefit]\",\n            \"priority\": \"P0|P1|P2\",\n            \"acceptance_criteria\": [\"criterion 1\", \"criterion 2\"]\n        }}\n    ],\n    \"tech_specs\": {{\n        \"architecture\": \"Architecture description\",\n        \"technology_stack\": [\"tech1\", \"tech2\"],\n        \"constraints\": [\"constraint1\"]\n    }},\n    \"acceptance_criteria\": [\"Overall criterion 1\", \"Overall criterion 2\"]\n}}\n\nEnsure:\n- At least one P0 user story\n- All stories have acceptance criteria\n- Tech specs include architecture decisions\n- Address all roundtable feedback\n\nOutput ONLY valid JSON, no additional text.",
                  "type": "str"
                },
                {
                  "name": "TASK_DECOMPOSITION_PROMPT",
                  "line": 252,
                  "value": "You are a senior software architect decomposing a PRD into tasks.\n\nPRD:\n{prd}\n\nBreak down this PRD into atomic, testable tasks following this JSON structure:\n[\n    {{\n        \"id\": \"TASK-001\",\n        \"description\": \"Task description\",\n        \"priority\": \"P0|P1|P2\",\n        \"type\": \"setup|code|test|docs\",\n        \"dependencies\": [\"TASK-000\"],\n        \"estimated_hours\": 2.0,\n        \"model_hint\": \"coding|planning|validation|fast\",\n        \"verification\": {{\n            \"type\": \"test_pass|file_exists\",\n            \"command\": \"pytest tests/...\"\n        }},\n        \"instruction\": \"Detailed implementation instructions\"\n    }}\n]\n\nGuidelines:\n- Start with setup/infrastructure tasks\n- Each coding task should have test coverage\n- Consider dependencies carefully\n- P0 tasks are critical path\n- Estimate hours realistically\n\nOutput ONLY valid JSON array, no additional text.",
                  "type": "str"
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "json"
                },
                {
                  "module": "logging"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "langgraph.graph",
                  "names": [
                    "END",
                    "START",
                    "StateGraph"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing_extensions",
                  "names": [
                    "TypedDict"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.client",
                  "names": [
                    "MCPClient"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.memory.neo4j",
                  "names": [
                    "Neo4jConnector"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "Taskmaster",
                "Task",
                "PRDOutput",
                "PlannerState",
                "PlannerStatus",
                "RoundtablePersona"
              ]
            },
            {
              "name": "task_decomposer.py",
              "path": "daw_agents/agents/planner/task_decomposer.py",
              "description": "Task Decomposition Agent for DAW Workbench.",
              "classes": [
                {
                  "name": "TaskVerification",
                  "line": 88,
                  "description": "Verification criteria for a task.\n\nMatches the verification field in tasks.json schema.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "model_dump",
                      "line": 102,
                      "visibility": "public",
                      "async": false,
                      "return_type": "dict[str, Any]",
                      "description": "Serialize to dict, excluding None values."
                    }
                  ],
                  "properties": [
                    {
                      "name": "type",
                      "line": 94,
                      "type": "VerificationType"
                    },
                    {
                      "name": "command",
                      "line": 95,
                      "type": "str | None"
                    },
                    {
                      "name": "path",
                      "line": 98,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "DecomposedTask",
                  "line": 111,
                  "description": "Represents a decomposed task matching tasks.json schema.\n\nAll fields are designed to be compatible with the existing\ntasks.json format used by the DAW workbench.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "model_dump",
                      "line": 141,
                      "visibility": "public",
                      "async": false,
                      "return_type": "dict[str, Any]",
                      "description": "Serialize to dict with proper enum handling."
                    }
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 118,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 119,
                      "type": "str"
                    },
                    {
                      "name": "priority",
                      "line": 120,
                      "type": "TaskPriority"
                    },
                    {
                      "name": "type",
                      "line": 121,
                      "type": "DecomposedTaskType"
                    },
                    {
                      "name": "dependencies",
                      "line": 122,
                      "type": "list[str]"
                    },
                    {
                      "name": "context_files",
                      "line": 125,
                      "type": "list[str]"
                    },
                    {
                      "name": "verification",
                      "line": 128,
                      "type": "TaskVerification | None"
                    },
                    {
                      "name": "estimated_hours",
                      "line": 131,
                      "type": "float | None"
                    },
                    {
                      "name": "model_hint",
                      "line": 134,
                      "type": "str | None"
                    },
                    {
                      "name": "instruction",
                      "line": 137,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "DecompositionResult",
                  "line": 156,
                  "description": "Result of PRD decomposition.\n\nContains all decomposed tasks and metadata.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "to_json",
                      "line": 170,
                      "visibility": "public",
                      "async": false,
                      "return_type": "str",
                      "description": "Serialize the result to JSON format."
                    },
                    {
                      "name": "to_tasks_json",
                      "line": 185,
                      "visibility": "public",
                      "async": false,
                      "return_type": "list[dict[str, Any]]",
                      "description": "Convert to tasks.json compatible format."
                    }
                  ],
                  "properties": [
                    {
                      "name": "prd_title",
                      "line": 162,
                      "type": "str"
                    },
                    {
                      "name": "tasks",
                      "line": 163,
                      "type": "list[DecomposedTask]"
                    },
                    {
                      "name": "total_estimated_hours",
                      "line": 166,
                      "type": "float"
                    }
                  ]
                },
                {
                  "name": "TaskDecomposerConfig",
                  "line": 194,
                  "description": "Configuration for TaskDecomposer.\n\nControls various aspects of task generation.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "max_tasks_per_feature",
                      "line": 200,
                      "type": "int"
                    },
                    {
                      "name": "min_task_hours",
                      "line": 203,
                      "type": "float"
                    },
                    {
                      "name": "max_task_hours",
                      "line": 206,
                      "type": "float"
                    },
                    {
                      "name": "id_prefix",
                      "line": 209,
                      "type": "str"
                    },
                    {
                      "name": "include_setup_tasks",
                      "line": 212,
                      "type": "bool"
                    },
                    {
                      "name": "include_test_tasks",
                      "line": 215,
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "TaskDecomposer",
                  "line": 271,
                  "description": "Decomposes PRD documents into atomic, testable tasks.\n\nIntegrates with:\n- PLANNER-001 (Taskmaster): Accepts PRDOutput\n- COMPLEXITY-001 (ComplexityAnalyzer): Uses complexity scores for sizing\n\nExample:\n    ```python\n    decomposer = TaskDecomposer()\n    result = await decomposer.decompose_prd(prd_markdown)\n    for task in result.tasks:\n        print(f\"{task.id}: {task.description}\")\n    ```",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 310,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model_router",
                          "type": "ModelRouter | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "complexity_analyzer",
                          "type": "ComplexityAnalyzer | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "config",
                          "type": "TaskDecomposerConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the TaskDecomposer."
                    },
                    {
                      "name": "decompose_prd",
                      "line": 330,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "prd",
                          "type": "str"
                        }
                      ],
                      "return_type": "DecompositionResult",
                      "description": "Decompose a PRD markdown into atomic tasks."
                    },
                    {
                      "name": "decompose_prd_output",
                      "line": 383,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "prd_output",
                          "type": "PRDOutput"
                        }
                      ],
                      "return_type": "DecompositionResult",
                      "description": "Decompose a PRDOutput object into tasks."
                    },
                    {
                      "name": "_prd_output_to_markdown",
                      "line": 398,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "prd_output",
                          "type": "PRDOutput"
                        }
                      ],
                      "return_type": "str",
                      "description": "Convert PRDOutput to markdown format."
                    },
                    {
                      "name": "_generate_tasks",
                      "line": 435,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "prd",
                          "type": "str"
                        },
                        {
                          "name": "complexity_analysis",
                          "type": "ComplexityAnalysis"
                        }
                      ],
                      "return_type": "str",
                      "description": "Generate tasks using LLM."
                    },
                    {
                      "name": "_parse_tasks",
                      "line": 470,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "raw_json",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[DecomposedTask]",
                      "description": "Parse raw JSON into DecomposedTask objects."
                    },
                    {
                      "name": "_extract_json",
                      "line": 530,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "text",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Extract JSON from text that may contain markdown."
                    },
                    {
                      "name": "_enrich_tasks",
                      "line": 566,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tasks",
                          "type": "list[DecomposedTask]"
                        },
                        {
                          "name": "complexity",
                          "type": "ComplexityAnalysis"
                        }
                      ],
                      "return_type": "list[DecomposedTask]",
                      "description": "Enrich tasks with metadata from complexity analysis."
                    },
                    {
                      "name": "_default_hours",
                      "line": 617,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task_type",
                          "type": "DecomposedTaskType"
                        }
                      ],
                      "return_type": "float",
                      "description": "Get default hours for a task type."
                    },
                    {
                      "name": "_order_tasks",
                      "line": 635,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tasks",
                          "type": "list[DecomposedTask]"
                        }
                      ],
                      "return_type": "list[DecomposedTask]",
                      "description": "Order tasks by dependencies using topological sort."
                    },
                    {
                      "name": "generate_task_id",
                      "line": 690,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "prefix",
                          "type": "str"
                        },
                        {
                          "name": "sequence",
                          "type": "int"
                        }
                      ],
                      "return_type": "str",
                      "description": "Generate a task ID with the given prefix."
                    },
                    {
                      "name": "infer_dependencies",
                      "line": 702,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tasks",
                          "type": "list[DecomposedTask]"
                        },
                        {
                          "name": "graph",
                          "type": "DependencyGraph"
                        }
                      ],
                      "return_type": "list[DecomposedTask]",
                      "description": "Infer task dependencies from complexity dependency graph."
                    },
                    {
                      "name": "infer_context_files",
                      "line": 746,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task",
                          "type": "DecomposedTask"
                        }
                      ],
                      "return_type": "list[str]",
                      "description": "Infer context files from task description."
                    },
                    {
                      "name": "generate_verification",
                      "line": 783,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task",
                          "type": "DecomposedTask"
                        }
                      ],
                      "return_type": "TaskVerification",
                      "description": "Generate verification criteria for a task."
                    },
                    {
                      "name": "estimate_hours",
                      "line": 827,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "complexity",
                          "type": "ComplexityScore"
                        }
                      ],
                      "return_type": "float",
                      "description": "Estimate hours from complexity score."
                    },
                    {
                      "name": "assign_model_hint",
                      "line": 856,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task",
                          "type": "DecomposedTask"
                        }
                      ],
                      "return_type": "str",
                      "description": "Assign model hint based on task type."
                    },
                    {
                      "name": "validate_task",
                      "line": 867,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task",
                          "type": "DecomposedTask"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Validate a single task."
                    },
                    {
                      "name": "validate_all",
                      "line": 886,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tasks",
                          "type": "list[DecomposedTask]"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Validate all tasks."
                    }
                  ],
                  "properties": [
                    {
                      "name": "TYPE_TO_HINT",
                      "line": 288,
                      "type": "dict[DecomposedTaskType, str]"
                    },
                    {
                      "name": "COMPLEXITY_HOURS",
                      "line": 297,
                      "type": "dict[int, float]"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "TaskPriority",
                  "kind": "enum",
                  "line": 53,
                  "description": "Task priority levels matching tasks.json schema.",
                  "members": [
                    {
                      "name": "P0",
                      "value": "P0"
                    },
                    {
                      "name": "P1",
                      "value": "P1"
                    },
                    {
                      "name": "P2",
                      "value": "P2"
                    }
                  ]
                },
                {
                  "name": "DecomposedTaskType",
                  "kind": "enum",
                  "line": 61,
                  "description": "Task type values matching tasks.json schema.",
                  "members": [
                    {
                      "name": "SETUP",
                      "value": "setup"
                    },
                    {
                      "name": "CODE",
                      "value": "code"
                    },
                    {
                      "name": "TEST",
                      "value": "test"
                    },
                    {
                      "name": "DOCS",
                      "value": "docs"
                    },
                    {
                      "name": "CONFIG",
                      "value": "config"
                    }
                  ]
                },
                {
                  "name": "VerificationType",
                  "kind": "enum",
                  "line": 75,
                  "description": "Verification type for tasks.",
                  "members": [
                    {
                      "name": "TEST_PASS",
                      "value": "test_pass"
                    },
                    {
                      "name": "FILE_EXISTS",
                      "value": "file_exists"
                    },
                    {
                      "name": "MANUAL",
                      "value": "manual"
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "TASK_DECOMPOSITION_PROMPT",
                  "line": 225,
                  "value": "You are an expert software architect decomposing a PRD into atomic, testable tasks.\n\nPRD:\n{prd}\n\nCOMPLEXITY ANALYSIS:\n{complexity_analysis}\n\nBreak down this PRD into atomic, testable tasks following this JSON structure:\n[\n    {{\n        \"id\": \"TASK-001\",\n        \"description\": \"Clear, actionable task description\",\n        \"priority\": \"P0|P1|P2\",\n        \"type\": \"setup|code|test|docs|config\",\n        \"dependencies\": [\"TASK-000\"],\n        \"context_files\": [\"src/path/to/file.py\"],\n        \"verification\": {{\n            \"type\": \"test_pass|file_exists\",\n            \"command\": \"pytest tests/...\"\n        }},\n        \"instruction\": \"Detailed implementation instructions\"\n    }}\n]\n\nGuidelines:\n1. Start with setup/infrastructure tasks (type: \"setup\")\n2. Each feature should have corresponding test tasks (type: \"test\")\n3. Use complexity scores to size tasks appropriately:\n   - cognitive_load 1-3: simple task, 0.5-1 hour\n   - cognitive_load 4-6: medium task, 1-3 hours\n   - cognitive_load 7-8: complex task, 3-5 hours\n   - cognitive_load 9-10: very complex task, 5-8 hours\n4. Order dependencies correctly (setup before code, code before test)\n5. Assign P0 to critical path tasks, P1 to important, P2 to nice-to-have\n6. Include context_files for each coding task\n7. Include verification criteria (prefer test_pass over file_exists)\n\nOutput ONLY valid JSON array, no additional text.",
                  "type": "str"
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "json"
                },
                {
                  "module": "logging"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.planner.complexity_analyzer",
                  "names": [
                    "ComplexityAnalysis",
                    "ComplexityAnalyzer",
                    "ComplexityScore",
                    "DependencyGraph",
                    "RiskRating"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.planner.taskmaster",
                  "names": [
                    "PRDOutput"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "TaskDecomposer",
                "TaskDecomposerConfig",
                "DecomposedTask",
                "DecompositionResult",
                "TaskVerification",
                "TaskPriority",
                "TaskType",
                "VerificationType"
              ]
            },
            {
              "name": "models.py",
              "path": "daw_agents/agents/healer/models.py",
              "description": "Pydantic models for the Healer Agent.",
              "classes": [
                {
                  "name": "ErrorInfo",
                  "line": 47,
                  "description": "Information about a failed tool output.\n\nAttributes:\n    tool_name: Name of the tool that produced the error\n    error_type: Type/category of the error (e.g., TestFailure, SyntaxError)\n    error_message: The actual error message\n    stack_trace: Stack trace if available\n    source_file: Path to the source file with the error\n    test_file: Path to the test file\n    source_code: Current source code content\n    test_code: Test code that's failing",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "to_signature",
                      "line": 70,
                      "visibility": "public",
                      "async": false,
                      "return_type": "str",
                      "description": "Generate an error signature for matching similar errors."
                    }
                  ],
                  "properties": [
                    {
                      "name": "tool_name",
                      "line": 61,
                      "type": "str"
                    },
                    {
                      "name": "error_type",
                      "line": 62,
                      "type": "str"
                    },
                    {
                      "name": "error_message",
                      "line": 63,
                      "type": "str"
                    },
                    {
                      "name": "stack_trace",
                      "line": 64,
                      "type": "str"
                    },
                    {
                      "name": "source_file",
                      "line": 65,
                      "type": "str"
                    },
                    {
                      "name": "test_file",
                      "line": 66,
                      "type": "str"
                    },
                    {
                      "name": "source_code",
                      "line": 67,
                      "type": "str"
                    },
                    {
                      "name": "test_code",
                      "line": 68,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "FixSuggestion",
                  "line": 88,
                  "description": "A suggested fix for an error.\n\nAttributes:\n    description: Human-readable description of the fix\n    fixed_code: The corrected code\n    confidence: Confidence score (0.0 to 1.0)\n    based_on_past_resolution: Whether this fix is based on a past resolution\n    past_resolution_id: ID of the past resolution if applicable",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "description",
                      "line": 99,
                      "type": "str"
                    },
                    {
                      "name": "fixed_code",
                      "line": 100,
                      "type": "str"
                    },
                    {
                      "name": "confidence",
                      "line": 101,
                      "type": "float"
                    },
                    {
                      "name": "based_on_past_resolution",
                      "line": 104,
                      "type": "bool"
                    },
                    {
                      "name": "past_resolution_id",
                      "line": 107,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "KnowledgeEntry",
                  "line": 112,
                  "description": "A stored error resolution for future RAG retrieval.\n\nAttributes:\n    id: Unique identifier for this entry\n    error_signature: Normalized error signature for matching\n    error_type: Type of error\n    error_pattern: Regex or pattern to match similar errors\n    resolution_description: Description of how the error was fixed\n    resolution_code: The code that fixed the error\n    success_count: Number of times this resolution succeeded\n    failure_count: Number of times this resolution failed\n    created_at: When this entry was created\n    last_used_at: When this entry was last used",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "success_rate",
                      "line": 146,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "float",
                      "description": "Calculate the success rate of this resolution."
                    }
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 128,
                      "type": "str"
                    },
                    {
                      "name": "error_signature",
                      "line": 129,
                      "type": "str"
                    },
                    {
                      "name": "error_type",
                      "line": 130,
                      "type": "str"
                    },
                    {
                      "name": "error_pattern",
                      "line": 131,
                      "type": "str"
                    },
                    {
                      "name": "resolution_description",
                      "line": 132,
                      "type": "str"
                    },
                    {
                      "name": "resolution_code",
                      "line": 133,
                      "type": "str"
                    },
                    {
                      "name": "success_count",
                      "line": 134,
                      "type": "int"
                    },
                    {
                      "name": "failure_count",
                      "line": 135,
                      "type": "int"
                    },
                    {
                      "name": "created_at",
                      "line": 136,
                      "type": "str"
                    },
                    {
                      "name": "last_used_at",
                      "line": 140,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "ValidationResult",
                  "line": 158,
                  "description": "Result of running validation tests.\n\nAttributes:\n    passed: Whether all tests passed\n    output: Full output from test execution\n    exit_code: Exit code from the test runner\n    duration_ms: Time taken to run tests in milliseconds\n    error: Error message if test execution failed",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "passed",
                      "line": 169,
                      "type": "bool"
                    },
                    {
                      "name": "output",
                      "line": 170,
                      "type": "str"
                    },
                    {
                      "name": "exit_code",
                      "line": 171,
                      "type": "int"
                    },
                    {
                      "name": "duration_ms",
                      "line": 172,
                      "type": "float"
                    },
                    {
                      "name": "error",
                      "line": 173,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "HealerResult",
                  "line": 176,
                  "description": "Final result of the Healer Agent workflow.\n\nAttributes:\n    success: Whether the healing task completed successfully\n    fixed_code: The fixed code if successful\n    fix_description: Description of the fix applied\n    attempts: Number of attempts taken\n    status: Final workflow status\n    knowledge_entry_id: ID of the knowledge entry created (if successful)\n    error: Error message if workflow failed",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "success",
                      "line": 189,
                      "type": "bool"
                    },
                    {
                      "name": "fixed_code",
                      "line": 190,
                      "type": "str"
                    },
                    {
                      "name": "fix_description",
                      "line": 191,
                      "type": "str"
                    },
                    {
                      "name": "attempts",
                      "line": 192,
                      "type": "int"
                    },
                    {
                      "name": "status",
                      "line": 193,
                      "type": "str"
                    },
                    {
                      "name": "knowledge_entry_id",
                      "line": 194,
                      "type": "str | None"
                    },
                    {
                      "name": "error",
                      "line": 197,
                      "type": "str | None"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "HealerStatus",
                  "kind": "enum",
                  "line": 25,
                  "description": "Status enum for Healer Agent workflow states.\n\nThe Healer follows error recovery workflow:\n- DIAGNOSE: Analyze the failed tool output\n- QUERY_KNOWLEDGE: Search Neo4j for similar past errors\n- SUGGEST_FIX: Generate fix based on error and past resolutions\n- APPLY_FIX: Apply the suggested fix\n- VALIDATE: Run tests to verify the fix worked\n- COMPLETE: Workflow completed successfully\n- ERROR: Workflow encountered an unrecoverable error",
                  "members": [
                    {
                      "name": "DIAGNOSE",
                      "value": "diagnose"
                    },
                    {
                      "name": "QUERY_KNOWLEDGE",
                      "value": "query_knowledge"
                    },
                    {
                      "name": "SUGGEST_FIX",
                      "value": "suggest_fix"
                    },
                    {
                      "name": "APPLY_FIX",
                      "value": "apply_fix"
                    },
                    {
                      "name": "VALIDATE",
                      "value": "validate"
                    },
                    {
                      "name": "COMPLETE",
                      "value": "complete"
                    },
                    {
                      "name": "ERROR",
                      "value": "error"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "hashlib"
                },
                {
                  "module": "datetime",
                  "names": [
                    "datetime"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "graph.py",
              "path": "daw_agents/agents/healer/graph.py",
              "description": "Healer Agent implementation using LangGraph.",
              "classes": [
                {
                  "name": "Healer",
                  "line": 61,
                  "description": "Healer Agent for error recovery and self-healing.\n\nThe Healer Agent implements an error recovery workflow:\n1. Diagnose error from failed tool output\n2. Query Neo4j knowledge graph for similar past errors\n3. Generate fix suggestion using LLM + RAG\n4. Apply fix to failing code\n5. Validate fix by running tests\n6. Store successful resolutions for future RAG\n\nThe agent uses ModelRouter with TaskType.CODING for fix generation\nand Neo4j for storing and retrieving past error resolutions.\n\nAttributes:\n    router: ModelRouter instance for LLM calls\n    task_type: Always TaskType.CODING for fix generation\n    max_attempts: Maximum healing attempts to prevent infinite loops (default: 3)\n    graph: Compiled LangGraph workflow\n    neo4j_connector: Optional Neo4j connector for knowledge graph\n    mcp_client: Optional MCP client for tool integration\n\nExample:\n    healer = Healer()\n    error_info = ErrorInfo(\n        tool_name=\"run_test\",\n        error_type=\"TestFailure\",\n        error_message=\"AssertionError: assert 1 + 1 == 3\",\n        source_file=\"src/calc.py\",\n        test_file=\"tests/test_calc.py\",\n        source_code=\"def add(a, b): return a + b + 1\",\n        test_code=\"def test_add(): assert add(1, 1) == 2\"\n    )\n    result = await healer.heal(error_info)\n    if result.success:\n        print(f\"Fixed code:\\n{result.fixed_code}\")",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 99,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "router",
                          "type": "ModelRouter | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "max_attempts",
                          "type": "int",
                          "default": "3",
                          "optional": true
                        },
                        {
                          "name": "neo4j_connector",
                          "type": "Neo4jConnector | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "mcp_client",
                          "type": "MCPClient | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the Healer Agent."
                    },
                    {
                      "name": "_build_graph",
                      "line": 127,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "Any",
                      "description": "Build the LangGraph error recovery workflow."
                    },
                    {
                      "name": "configure_neo4j",
                      "line": 203,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "neo4j_connector",
                          "type": "Neo4jConnector"
                        }
                      ],
                      "return_type": "None",
                      "description": "Configure Neo4j connector for knowledge graph queries."
                    },
                    {
                      "name": "configure_mcp",
                      "line": 212,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "mcp_client",
                          "type": "MCPClient"
                        }
                      ],
                      "return_type": "None",
                      "description": "Configure MCP client for tool integration."
                    },
                    {
                      "name": "heal",
                      "line": 221,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "error_info",
                          "type": "ErrorInfo"
                        }
                      ],
                      "return_type": "HealerResult",
                      "description": "Execute the healing workflow for a given error."
                    },
                    {
                      "name": "diagnose",
                      "line": 306,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "error_info",
                          "type": "ErrorInfo"
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Diagnose an error without running the full healing workflow."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING",
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "langgraph.graph",
                  "names": [
                    "END",
                    "START",
                    "StateGraph"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.healer.models",
                  "names": [
                    "ErrorInfo",
                    "HealerResult"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.healer.nodes",
                  "names": [
                    "apply_fix_node",
                    "diagnose_error_node",
                    "query_knowledge_graph_node",
                    "route_after_apply_fix",
                    "route_after_diagnose",
                    "route_after_query_knowledge",
                    "route_after_suggest_fix",
                    "route_after_validate",
                    "store_resolution",
                    "suggest_fix_node",
                    "validate_fix_node"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.healer.state",
                  "names": [
                    "HealerState"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.client",
                  "names": [
                    "MCPClient"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.memory.neo4j",
                  "names": [
                    "Neo4jConnector"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/agents/healer/__init__.py",
              "description": "Healer Agent package for error recovery and self-healing.",
              "imports": [
                {
                  "module": "daw_agents.agents.healer.graph",
                  "names": [
                    "Healer"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.healer.models",
                  "names": [
                    "ErrorInfo",
                    "FixSuggestion",
                    "HealerResult",
                    "HealerStatus",
                    "KnowledgeEntry",
                    "ValidationResult"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.healer.state",
                  "names": [
                    "HealerState"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "Healer",
                "HealerState",
                "HealerStatus",
                "HealerResult",
                "ErrorInfo",
                "FixSuggestion",
                "KnowledgeEntry",
                "ValidationResult"
              ]
            },
            {
              "name": "nodes.py",
              "path": "daw_agents/agents/healer/nodes.py",
              "description": "Node functions for the Healer Agent LangGraph workflow.",
              "functions": [
                {
                  "name": "analyze_error",
                  "line": 40,
                  "description": "Analyze the error to extract signature and root cause.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "error_info",
                      "type": "dict[str, Any]"
                    }
                  ]
                },
                {
                  "name": "query_similar_errors",
                  "line": 65,
                  "description": "Query Neo4j for similar past errors.",
                  "async": true,
                  "return_type": "list[dict[str, Any]]",
                  "parameters": [
                    {
                      "name": "error_signature",
                      "type": "str"
                    },
                    {
                      "name": "error_type",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "generate_fix_suggestion",
                  "line": 87,
                  "description": "Generate a fix suggestion using LLM.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "error_info",
                      "type": "dict[str, Any]"
                    },
                    {
                      "name": "similar_errors",
                      "type": "list[dict[str, Any]]"
                    },
                    {
                      "name": "previous_attempts",
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "apply_code_fix",
                  "line": 116,
                  "description": "Apply the suggested fix to the source code.",
                  "async": true,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "source_code",
                      "type": "str"
                    },
                    {
                      "name": "fix_suggestion",
                      "type": "dict[str, Any]"
                    }
                  ]
                },
                {
                  "name": "run_validation_tests",
                  "line": 138,
                  "description": "Run validation tests on the fixed code.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "fixed_code",
                      "type": "str"
                    },
                    {
                      "name": "test_code",
                      "type": "str"
                    },
                    {
                      "name": "source_file",
                      "type": "str"
                    },
                    {
                      "name": "test_file",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "store_to_neo4j",
                  "line": 169,
                  "description": "Store a successful resolution in Neo4j.",
                  "async": true,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "error_signature",
                      "type": "str"
                    },
                    {
                      "name": "error_type",
                      "type": "str"
                    },
                    {
                      "name": "fix_description",
                      "type": "str"
                    },
                    {
                      "name": "fixed_code",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "store_resolution",
                  "line": 196,
                  "description": "Store a successful error resolution in Neo4j knowledge graph.",
                  "async": true,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "error_info",
                      "type": "ErrorInfo"
                    },
                    {
                      "name": "fix_description",
                      "type": "str"
                    },
                    {
                      "name": "fixed_code",
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "diagnose_error_node",
                  "line": 229,
                  "description": "Analyze the failed tool output to extract error signature.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "query_knowledge_graph_node",
                  "line": 258,
                  "description": "Search Neo4j for similar past errors and their resolutions.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "suggest_fix_node",
                  "line": 290,
                  "description": "Generate a fix suggestion using LLM.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "apply_fix_node",
                  "line": 316,
                  "description": "Apply the suggested fix to the failing code.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "validate_fix_node",
                  "line": 348,
                  "description": "Run validation tests on the fixed code.",
                  "async": true,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "route_after_diagnose",
                  "line": 377,
                  "description": "Route after diagnose_error node.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "route_after_query_knowledge",
                  "line": 391,
                  "description": "Route after query_knowledge_graph node.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "route_after_suggest_fix",
                  "line": 405,
                  "description": "Route after suggest_fix node.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "route_after_apply_fix",
                  "line": 419,
                  "description": "Route after apply_fix node.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                },
                {
                  "name": "route_after_validate",
                  "line": 433,
                  "description": "Route after validate_fix node based on results.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "state",
                      "type": "HealerState"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.healer.models",
                  "names": [
                    "ErrorInfo"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.agents.healer.state",
                  "names": [
                    "HealerState"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "state.py",
              "path": "daw_agents/agents/healer/state.py",
              "description": "Healer state definition for Healer Agent.",
              "types": [
                {
                  "name": "HealerState",
                  "kind": "typed_dict",
                  "line": 27,
                  "description": "State schema for the Healer Agent LangGraph workflow.\n\nAttributes:\n    error_info: Information about the failed tool output to heal\n    similar_errors: List of similar errors found in Neo4j knowledge graph\n    fix_suggestion: Suggested fix from LLM (None if not yet generated)\n    fixed_code: The code after applying the fix\n    status: Current workflow status (diagnose, query_knowledge, suggest_fix,\n            apply_fix, validate, complete, error)\n    validation_result: Result from running validation tests (None if not yet run)\n    attempt: Current attempt count (starts at 0)\n    max_attempts: Maximum allowed attempts (default 3)\n    error: Error message if workflow fails (None if no error)",
                  "members": [
                    {
                      "name": "error_info",
                      "type": "dict[str, Any]"
                    },
                    {
                      "name": "similar_errors",
                      "type": "list[dict[str, Any]]"
                    },
                    {
                      "name": "fix_suggestion",
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "fixed_code",
                      "type": "str"
                    },
                    {
                      "name": "status",
                      "type": "str"
                    },
                    {
                      "name": "validation_result",
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "attempt",
                      "type": "int"
                    },
                    {
                      "name": "max_attempts",
                      "type": "int"
                    },
                    {
                      "name": "error",
                      "type": "str | None"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any",
                    "TypedDict"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        },
        "mcp": {
          "name": "mcp",
          "path": "src/daw_agents/mcp",
          "description": "",
          "modules": [
            {
              "name": "gateway.py",
              "path": "daw_agents/mcp/gateway.py",
              "description": "MCP Gateway Authorization with OAuth 2.1 and RFC 8707 Resource Indicators.",
              "classes": [
                {
                  "name": "GatewayAuthError",
                  "line": 78,
                  "description": "Base exception for gateway authorization errors.",
                  "bases": [
                    "Exception"
                  ]
                },
                {
                  "name": "UnauthorizedAgentError",
                  "line": 84,
                  "description": "Raised when an unknown agent attempts to authorize.",
                  "bases": [
                    "GatewayAuthError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 87,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "agent_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "InsufficientScopeError",
                  "line": 92,
                  "description": "Raised when a tool call requires a scope the token doesn't have.",
                  "bases": [
                    "GatewayAuthError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 95,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tool_name",
                          "type": "str"
                        },
                        {
                          "name": "required_scope",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "TokenExpiredError",
                  "line": 104,
                  "description": "Raised when a token has expired.",
                  "bases": [
                    "GatewayAuthError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 107,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str",
                          "default": "'Token has expired'",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "TokenRevokedError",
                  "line": 111,
                  "description": "Raised when a token has been revoked.",
                  "bases": [
                    "GatewayAuthError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 114,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "token_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "InvalidTokenError",
                  "line": 119,
                  "description": "Raised when a token is invalid (malformed, bad signature, etc.).",
                  "bases": [
                    "GatewayAuthError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 122,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "InvalidRefreshTokenError",
                  "line": 126,
                  "description": "Raised when a refresh token is invalid or not found.",
                  "bases": [
                    "GatewayAuthError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 129,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "InvalidAudienceError",
                  "line": 133,
                  "description": "Raised when token audience doesn't match expected audience.",
                  "bases": [
                    "GatewayAuthError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 136,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "audience",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "InvalidResourceError",
                  "line": 141,
                  "description": "Raised when token resource indicator doesn't match expected resource.",
                  "bases": [
                    "GatewayAuthError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 144,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "resource",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "MCPGatewayConfig",
                  "line": 167,
                  "description": "Configuration for MCP Gateway Authorization.\n\nAttributes:\n    issuer: The issuer identifier (iss claim in JWT)\n    audience: The intended audience (aud claim in JWT)\n    secret_key: Secret key for signing tokens (HS256)\n    algorithm: JWT algorithm (default HS256)\n    automated_ttl_minutes: TTL for automated sessions (default 15)\n    interactive_ttl_minutes: TTL for interactive sessions (default 60)\n    resource_uri: RFC 8707 resource URI (optional)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "issuer",
                      "line": 180,
                      "type": "str"
                    },
                    {
                      "name": "audience",
                      "line": 181,
                      "type": "str"
                    },
                    {
                      "name": "secret_key",
                      "line": 182,
                      "type": "str"
                    },
                    {
                      "name": "algorithm",
                      "line": 183,
                      "type": "str"
                    },
                    {
                      "name": "automated_ttl_minutes",
                      "line": 184,
                      "type": "int"
                    },
                    {
                      "name": "interactive_ttl_minutes",
                      "line": 185,
                      "type": "int"
                    },
                    {
                      "name": "resource_uri",
                      "line": 186,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "AgentScope",
                  "line": 189,
                  "description": "Per-agent scope definition.\n\nAttributes:\n    agent_id: Unique identifier for the agent\n    scopes: List of allowed scopes (may include parametric scopes like query_db:SELECT)",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "has_scope",
                      "line": 200,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "scope",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if this agent has the specified scope."
                    }
                  ],
                  "properties": [
                    {
                      "name": "agent_id",
                      "line": 197,
                      "type": "str"
                    },
                    {
                      "name": "scopes",
                      "line": 198,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "ScopedToken",
                  "line": 217,
                  "description": "Represents an issued scoped token.\n\nAttributes:\n    token_id: Unique identifier for this token (jti claim)\n    agent_id: The agent this token was issued to\n    scopes: List of granted scopes\n    issued_at: When the token was issued\n    expires_at: When the token expires\n    token_string: The actual JWT string\n    refresh_token: Optional refresh token for token renewal\n    resource: RFC 8707 resource indicator (optional)\n    session_type: Type of session (automated/interactive)",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "is_expired",
                      "line": 242,
                      "visibility": "public",
                      "async": false,
                      "return_type": "bool",
                      "description": "Check if this token has expired."
                    }
                  ],
                  "properties": [
                    {
                      "name": "token_id",
                      "line": 232,
                      "type": "str"
                    },
                    {
                      "name": "agent_id",
                      "line": 233,
                      "type": "str"
                    },
                    {
                      "name": "scopes",
                      "line": 234,
                      "type": "list[str]"
                    },
                    {
                      "name": "issued_at",
                      "line": 235,
                      "type": "datetime"
                    },
                    {
                      "name": "expires_at",
                      "line": 236,
                      "type": "datetime"
                    },
                    {
                      "name": "token_string",
                      "line": 237,
                      "type": "str"
                    },
                    {
                      "name": "refresh_token",
                      "line": 238,
                      "type": "str | None"
                    },
                    {
                      "name": "resource",
                      "line": 239,
                      "type": "str | None"
                    },
                    {
                      "name": "session_type",
                      "line": 240,
                      "type": "SessionType"
                    }
                  ]
                },
                {
                  "name": "ToolCallResult",
                  "line": 251,
                  "description": "Result of a tool call validation.\n\nAttributes:\n    allowed: Whether the tool call is allowed\n    tool_name: Name of the tool being called\n    scope_match: The scope that matched (if allowed)\n    agent_id: The agent attempting the call\n    error: Error message (if not allowed)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "allowed",
                      "line": 262,
                      "type": "bool"
                    },
                    {
                      "name": "tool_name",
                      "line": 263,
                      "type": "str"
                    },
                    {
                      "name": "scope_match",
                      "line": 264,
                      "type": "str | None"
                    },
                    {
                      "name": "agent_id",
                      "line": 265,
                      "type": "str"
                    },
                    {
                      "name": "error",
                      "line": 266,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "MCPGateway",
                  "line": 274,
                  "description": "MCP Gateway for OAuth 2.1 + RFC 8707 authorization.\n\nThis gateway handles:\n- Agent authorization with scoped tokens\n- Token validation\n- Tool call authorization\n- Token refresh and revocation\n\nAttributes:\n    config: Gateway configuration\n    agent_scopes: Mapping of agent IDs to allowed scopes",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 288,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "MCPGatewayConfig"
                        },
                        {
                          "name": "agent_scopes",
                          "type": "dict[str, list[str]] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the MCP Gateway."
                    },
                    {
                      "name": "authorize_agent",
                      "line": 313,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "agent_id",
                          "type": "str"
                        },
                        {
                          "name": "requested_scopes",
                          "type": "list[str]"
                        },
                        {
                          "name": "session_type",
                          "type": "SessionType",
                          "default": "SessionType.AUTOMATED",
                          "optional": true
                        },
                        {
                          "name": "with_refresh_token",
                          "type": "bool",
                          "default": "False",
                          "optional": true
                        }
                      ],
                      "return_type": "ScopedToken",
                      "description": "Issue a scoped token for an agent."
                    },
                    {
                      "name": "validate_token",
                      "line": 408,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "token_string",
                          "type": "str"
                        },
                        {
                          "name": "expected_resource",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "ScopedToken",
                      "description": "Validate a token and return its information."
                    },
                    {
                      "name": "validate_tool_call",
                      "line": 490,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "token",
                          "type": "str"
                        },
                        {
                          "name": "tool_name",
                          "type": "str"
                        },
                        {
                          "name": "params",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "ToolCallResult",
                      "description": "Validate a tool call against the token's scopes."
                    },
                    {
                      "name": "_find_matching_scope",
                      "line": 536,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tool_name",
                          "type": "str"
                        },
                        {
                          "name": "params",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "scopes",
                          "type": "list[str]"
                        }
                      ],
                      "return_type": "str | None",
                      "description": "Find a scope that matches the tool call."
                    },
                    {
                      "name": "_operation_matches_scope",
                      "line": 570,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "params",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "scope_param",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if an operation matches a parametric scope."
                    },
                    {
                      "name": "refresh_token",
                      "line": 611,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "refresh_token_string",
                          "type": "str"
                        }
                      ],
                      "return_type": "ScopedToken",
                      "description": "Refresh an access token using a refresh token."
                    },
                    {
                      "name": "revoke_token",
                      "line": 656,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "token_string",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Revoke a token, making it immediately invalid."
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "SessionType",
                  "kind": "enum",
                  "line": 62,
                  "description": "Session type determines token TTL.\n\nAUTOMATED: 15-minute TTL for agent-to-agent automated workflows\nINTERACTIVE: 1-hour TTL for human-interactive sessions",
                  "members": [
                    {
                      "name": "AUTOMATED",
                      "value": "automated"
                    },
                    {
                      "name": "INTERACTIVE",
                      "value": "interactive"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "secrets"
                },
                {
                  "module": "uuid"
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime",
                    "timedelta"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "jwt"
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "audit.py",
              "path": "daw_agents/mcp/audit.py",
              "description": "MCP Audit Logging for SOC 2/ISO 27001 Compliance (MCP-SEC-003).",
              "classes": [
                {
                  "name": "AuditConfig",
                  "line": 104,
                  "description": "Configuration for MCP Audit Logging.\n\nAttributes:\n    retention_days: Number of days to retain audit logs (default: 2555 = 7 years)\n    hash_algorithm: Hash algorithm for chain integrity (default: sha256)\n    enable_helicone: Whether to report to Helicone for observability\n    max_parameter_length: Maximum length for parameter values in logs\n    sanitize_sensitive_keys: Keys to redact from parameters",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "retention_days",
                      "line": 115,
                      "type": "int"
                    },
                    {
                      "name": "hash_algorithm",
                      "line": 120,
                      "type": "str"
                    },
                    {
                      "name": "enable_helicone",
                      "line": 124,
                      "type": "bool"
                    },
                    {
                      "name": "max_parameter_length",
                      "line": 128,
                      "type": "int"
                    },
                    {
                      "name": "sanitize_sensitive_keys",
                      "line": 133,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "AuditEntry",
                  "line": 152,
                  "description": "Audit log entry for a single tool call.\n\nCaptures all required information per FR-01.3.3:\n- timestamp, agent_id, user_id, tool name, action, parameters,\n  result status, response time\n\nSupports hash-chaining via entry_hash and previous_hash fields.\n\nAttributes:\n    entry_id: Unique identifier for this entry\n    timestamp: When the tool call occurred (UTC)\n    agent_id: ID of the agent making the call\n    user_id: ID of the user who initiated the workflow\n    tool_name: Name of the tool being called\n    action: Type of action (execute, query, etc.)\n    parameters: Call parameters (sanitized)\n    result_status: Result of the call\n    response_time_ms: Call duration in milliseconds\n    previous_hash: Hash of the previous entry (for chain integrity)\n    entry_hash: Hash of this entry (computed on creation)\n    error_details: Error message if call failed\n    session_id: Optional session ID for tracing\n    token_id: Optional token ID for auth tracing\n    retention_until: When this entry can be deleted",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "entry_id",
                      "line": 179,
                      "type": "str"
                    },
                    {
                      "name": "timestamp",
                      "line": 180,
                      "type": "datetime"
                    },
                    {
                      "name": "agent_id",
                      "line": 181,
                      "type": "str"
                    },
                    {
                      "name": "user_id",
                      "line": 182,
                      "type": "str"
                    },
                    {
                      "name": "tool_name",
                      "line": 183,
                      "type": "str"
                    },
                    {
                      "name": "action",
                      "line": 184,
                      "type": "str"
                    },
                    {
                      "name": "parameters",
                      "line": 185,
                      "type": "dict[str, Any]"
                    },
                    {
                      "name": "result_status",
                      "line": 189,
                      "type": "ResultStatus"
                    },
                    {
                      "name": "response_time_ms",
                      "line": 190,
                      "type": "int"
                    },
                    {
                      "name": "previous_hash",
                      "line": 193,
                      "type": "str | None"
                    },
                    {
                      "name": "entry_hash",
                      "line": 197,
                      "type": "str | None"
                    },
                    {
                      "name": "error_details",
                      "line": 203,
                      "type": "str | None"
                    },
                    {
                      "name": "session_id",
                      "line": 207,
                      "type": "str | None"
                    },
                    {
                      "name": "token_id",
                      "line": 211,
                      "type": "str | None"
                    },
                    {
                      "name": "retention_until",
                      "line": 215,
                      "type": "datetime | None"
                    }
                  ]
                },
                {
                  "name": "AuditLogger",
                  "line": 317,
                  "description": "Logger for MCP tool call audit trail.\n\nProvides:\n- log_tool_call(): Log a tool call with all metadata\n- query_audit_trail(): Query historical audit entries\n- get_audit_statistics(): Get summary statistics\n- export_audit_trail(): Export audit trail in JSON/CSV\n- purge_expired_entries(): Remove entries past retention\n\nThe logger maintains a hash chain for tamper resistance. Each entry\nincludes a hash of its content plus the previous entry's hash.\n\nSupports Neo4j for persistent storage and Helicone for observability.\n\nAttributes:\n    config: Audit configuration\n    neo4j_connector: Optional Neo4j connector for persistence\n    helicone_tracker: Optional Helicone tracker for observability",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 338,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "AuditConfig"
                        },
                        {
                          "name": "neo4j_connector",
                          "type": "Neo4jConnector | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "helicone_tracker",
                          "type": "HeliconeTracker | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the audit logger."
                    },
                    {
                      "name": "_sanitize_parameters",
                      "line": 366,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "params",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Sanitize parameters by redacting sensitive values."
                    },
                    {
                      "name": "log_tool_call",
                      "line": 395,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "agent_id",
                          "type": "str"
                        },
                        {
                          "name": "user_id",
                          "type": "str"
                        },
                        {
                          "name": "tool_name",
                          "type": "str"
                        },
                        {
                          "name": "action",
                          "type": "str"
                        },
                        {
                          "name": "parameters",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "success",
                          "type": "bool | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "denied",
                          "type": "bool",
                          "default": "False",
                          "optional": true
                        },
                        {
                          "name": "response_time_ms",
                          "type": "int",
                          "default": "0",
                          "optional": true
                        },
                        {
                          "name": "error_details",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "session_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "token_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "AuditEntry",
                      "description": "Log a tool call to the audit trail."
                    },
                    {
                      "name": "_persist_to_neo4j",
                      "line": 494,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "entry",
                          "type": "AuditEntry"
                        }
                      ],
                      "return_type": "str | None",
                      "description": "Persist an audit entry to Neo4j."
                    },
                    {
                      "name": "_report_to_helicone",
                      "line": 539,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "entry",
                          "type": "AuditEntry"
                        }
                      ],
                      "return_type": "None",
                      "description": "Report audit entry to Helicone for observability."
                    },
                    {
                      "name": "query_audit_trail",
                      "line": 566,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "agent_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "user_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "tool_name",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "result_status",
                          "type": "ResultStatus | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "start_time",
                          "type": "datetime | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "end_time",
                          "type": "datetime | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "session_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "limit",
                          "type": "int | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "list[AuditEntry]",
                      "description": "Query the audit trail with filters."
                    },
                    {
                      "name": "_query_from_neo4j",
                      "line": 638,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "agent_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "user_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "tool_name",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "result_status",
                          "type": "ResultStatus | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "start_time",
                          "type": "datetime | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "end_time",
                          "type": "datetime | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "session_id",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "limit",
                          "type": "int | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "list[AuditEntry]",
                      "description": "Query audit trail from Neo4j."
                    },
                    {
                      "name": "get_audit_statistics",
                      "line": 739,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "start_time",
                          "type": "datetime | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "end_time",
                          "type": "datetime | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Get summary statistics for audit entries."
                    },
                    {
                      "name": "export_audit_trail",
                      "line": 805,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "format",
                          "type": "str",
                          "default": "'json'",
                          "optional": true
                        },
                        {
                          "name": "start_time",
                          "type": "datetime | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "end_time",
                          "type": "datetime | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "str",
                      "description": "Export audit trail in JSON or CSV format."
                    },
                    {
                      "name": "purge_expired_entries",
                      "line": 853,
                      "visibility": "public",
                      "async": true,
                      "return_type": "int",
                      "description": "Purge audit entries past their retention period."
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "compute_entry_hash",
                  "line": 226,
                  "description": "Compute SHA-256 hash of an audit entry for chain integrity.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "entry",
                      "type": "AuditEntry"
                    },
                    {
                      "name": "algorithm",
                      "type": "str",
                      "default": "'sha256'",
                      "optional": true
                    }
                  ]
                },
                {
                  "name": "verify_chain_integrity",
                  "line": 264,
                  "description": "Verify the integrity of an audit entry chain.",
                  "async": false,
                  "return_type": "bool",
                  "parameters": [
                    {
                      "name": "entries",
                      "type": "list[AuditEntry]"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "ResultStatus",
                  "kind": "enum",
                  "line": 82,
                  "description": "Status of a tool call result.\n\nSUCCESS: Tool call completed successfully\nFAILURE: Tool call failed (business logic error)\nERROR: Tool call encountered an unexpected error\nDENIED: Tool call was denied due to insufficient permissions\nTIMEOUT: Tool call timed out",
                  "members": [
                    {
                      "name": "SUCCESS",
                      "value": "success"
                    },
                    {
                      "name": "FAILURE",
                      "value": "failure"
                    },
                    {
                      "name": "ERROR",
                      "value": "error"
                    },
                    {
                      "name": "DENIED",
                      "value": "denied"
                    },
                    {
                      "name": "TIMEOUT",
                      "value": "timeout"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "asyncio"
                },
                {
                  "module": "csv"
                },
                {
                  "module": "hashlib"
                },
                {
                  "module": "io"
                },
                {
                  "module": "json"
                },
                {
                  "module": "logging"
                },
                {
                  "module": "uuid"
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime",
                    "timedelta"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING",
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.memory.neo4j",
                  "names": [
                    "Neo4jConnector"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.ops.helicone",
                  "names": [
                    "HeliconeTracker"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "AuditConfig",
                "AuditEntry",
                "AuditLogger",
                "ResultStatus",
                "compute_entry_hash",
                "verify_chain_integrity"
              ]
            },
            {
              "name": "client.py",
              "path": "daw_agents/mcp/client.py",
              "description": "MCP Client Interface for Model Context Protocol.",
              "classes": [
                {
                  "name": "MCPTool",
                  "line": 35,
                  "description": "Represents a tool exposed by an MCP server.\n\nAttributes:\n    name: Unique identifier for the tool\n    description: Human-readable description of what the tool does\n    input_schema: JSON Schema defining the tool's input parameters",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "name",
                      "line": 44,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 45,
                      "type": "str"
                    },
                    {
                      "name": "input_schema",
                      "line": 46,
                      "type": "dict[str, Any]"
                    }
                  ]
                },
                {
                  "name": "MCPToolResult",
                  "line": 49,
                  "description": "Represents the result of a tool execution.\n\nAttributes:\n    success: Whether the tool executed successfully\n    result: The result data from the tool (if successful)\n    error: Error message (if unsuccessful)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "success",
                      "line": 58,
                      "type": "bool"
                    },
                    {
                      "name": "result",
                      "line": 59,
                      "type": "Any"
                    },
                    {
                      "name": "error",
                      "line": 60,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "JSONRPCError",
                  "line": 63,
                  "description": "Represents a JSON-RPC 2.0 error object.\n\nAttributes:\n    code: Error code (negative integer)\n    message: Human-readable error message\n    data: Additional error data (optional)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "code",
                      "line": 72,
                      "type": "int"
                    },
                    {
                      "name": "message",
                      "line": 73,
                      "type": "str"
                    },
                    {
                      "name": "data",
                      "line": 74,
                      "type": "Any"
                    }
                  ]
                },
                {
                  "name": "MCPClient",
                  "line": 82,
                  "description": "Client for interacting with MCP servers using JSON-RPC 2.0.\n\nThis client provides methods to:\n1. Discover available tools from an MCP server\n2. Execute tools with parameters\n3. Handle JSON-RPC errors gracefully\n\nThe client uses HTTP transport with JSON-RPC 2.0 protocol for communication.\n\nAttributes:\n    server_url: The base URL of the MCP server\n    server_name: A friendly name for this server connection\n    timeout: Request timeout in seconds\n\nExample:\n    client = MCPClient(\n        server_url=\"http://localhost:3001\",\n        server_name=\"git-server\"\n    )\n    tools = await client.discover_tools()\n    result = await client.call_tool(\"git_status\", params={})\n    await client.close()",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 107,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "server_url",
                          "type": "str"
                        },
                        {
                          "name": "server_name",
                          "type": "str",
                          "default": "'default'",
                          "optional": true
                        },
                        {
                          "name": "timeout",
                          "type": "float",
                          "default": "30.0",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the MCP client."
                    },
                    {
                      "name": "__aenter__",
                      "line": 126,
                      "visibility": "protected",
                      "async": true,
                      "return_type": "MCPClient",
                      "description": "Enter async context manager."
                    },
                    {
                      "name": "__aexit__",
                      "line": 131,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "exc_type",
                          "type": "type[BaseException] | None"
                        },
                        {
                          "name": "exc_val",
                          "type": "BaseException | None"
                        },
                        {
                          "name": "exc_tb",
                          "type": "object"
                        }
                      ],
                      "return_type": "None",
                      "description": "Exit async context manager."
                    },
                    {
                      "name": "_next_request_id",
                      "line": 140,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "int",
                      "description": "Generate the next request ID."
                    },
                    {
                      "name": "_build_request",
                      "line": 149,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "method",
                          "type": "str"
                        },
                        {
                          "name": "params",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Build a JSON-RPC 2.0 request object."
                    },
                    {
                      "name": "_send_request",
                      "line": 172,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "method",
                          "type": "str"
                        },
                        {
                          "name": "params",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Send a JSON-RPC request to the MCP server."
                    },
                    {
                      "name": "discover_tools",
                      "line": 213,
                      "visibility": "public",
                      "async": true,
                      "return_type": "list[MCPTool]",
                      "description": "Discover available tools from the MCP server."
                    },
                    {
                      "name": "call_tool",
                      "line": 262,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "tool_name",
                          "type": "str"
                        },
                        {
                          "name": "params",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "MCPToolResult",
                      "description": "Execute a tool on the MCP server."
                    },
                    {
                      "name": "close",
                      "line": 365,
                      "visibility": "public",
                      "async": true,
                      "return_type": "None",
                      "description": "Close the HTTP client connection."
                    }
                  ]
                },
                {
                  "name": "MCPClientManager",
                  "line": 381,
                  "description": "Manages multiple MCP server connections.\n\nProvides a centralized way to configure and access multiple MCP servers.\n\nExample:\n    manager = MCPClientManager()\n    manager.add_server(\"git\", \"http://localhost:3001\")\n    manager.add_server(\"filesystem\", \"http://localhost:3002\")\n\n    git_client = await manager.get_client(\"git\")\n    tools = await git_client.discover_tools()\n\n    await manager.close_all()",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 397,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Initialize the client manager."
                    },
                    {
                      "name": "add_server",
                      "line": 402,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "name",
                          "type": "str"
                        },
                        {
                          "name": "url",
                          "type": "str"
                        }
                      ],
                      "return_type": "None",
                      "description": "Add a server configuration."
                    },
                    {
                      "name": "get_client",
                      "line": 412,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "name",
                          "type": "str"
                        }
                      ],
                      "return_type": "MCPClient",
                      "description": "Get or create a client for a server."
                    },
                    {
                      "name": "close_all",
                      "line": 436,
                      "visibility": "public",
                      "async": true,
                      "return_type": "None",
                      "description": "Close all managed client connections."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "httpx"
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "rbac.py",
              "path": "daw_agents/mcp/rbac.py",
              "description": "RBAC (Role-Based Access Control) for MCP Tools.",
              "classes": [
                {
                  "name": "RBACError",
                  "line": 92,
                  "description": "Base exception for RBAC errors.",
                  "bases": [
                    "Exception"
                  ]
                },
                {
                  "name": "PolicyParseError",
                  "line": 98,
                  "description": "Raised when policy YAML cannot be parsed.",
                  "bases": [
                    "RBACError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 101,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "PermissionDeniedError",
                  "line": 106,
                  "description": "Raised when a permission check fails.",
                  "bases": [
                    "RBACError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 109,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "role",
                          "type": "str"
                        },
                        {
                          "name": "tool",
                          "type": "str"
                        },
                        {
                          "name": "reason",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "RoleNotFoundError",
                  "line": 116,
                  "description": "Raised when a role is not found in the policy.",
                  "bases": [
                    "RBACError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 119,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "role",
                          "type": "str"
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "Permission",
                  "line": 129,
                  "description": "Permission definition for a single tool.\n\nAttributes:\n    tool: The name of the tool this permission applies to\n    actions: List of allowed actions (e.g., [\"read\", \"write\"] or [\"SELECT\"])\n    scope: Optional scope restriction (e.g., \"{project_root}\", \"patches\")\n    conditions: Optional conditions dict (e.g., {\"requires_approval_in\": [\"production\"]})",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "tool",
                      "line": 139,
                      "type": "str"
                    },
                    {
                      "name": "actions",
                      "line": 140,
                      "type": "list[str]"
                    },
                    {
                      "name": "scope",
                      "line": 141,
                      "type": "str | None"
                    },
                    {
                      "name": "conditions",
                      "line": 142,
                      "type": "dict[str, Any] | None"
                    }
                  ]
                },
                {
                  "name": "PermissionContext",
                  "line": 145,
                  "description": "Context for permission checks.\n\nProvides contextual information for scope validation and conditional checks.\n\nAttributes:\n    path: The file path being accessed (if applicable)\n    project_root: The root directory of the project\n    environment: The deployment environment (development, staging, production)\n    query: The database query being executed (if applicable)",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "is_within_project",
                      "line": 162,
                      "visibility": "public",
                      "async": false,
                      "return_type": "bool",
                      "description": "Check if the path is within the project root."
                    },
                    {
                      "name": "is_patch_file",
                      "line": 180,
                      "visibility": "public",
                      "async": false,
                      "return_type": "bool",
                      "description": "Check if the path is a patch file."
                    },
                    {
                      "name": "is_production",
                      "line": 192,
                      "visibility": "public",
                      "async": false,
                      "return_type": "bool",
                      "description": "Check if the environment is production."
                    }
                  ],
                  "properties": [
                    {
                      "name": "path",
                      "line": 157,
                      "type": "str | None"
                    },
                    {
                      "name": "project_root",
                      "line": 158,
                      "type": "str | None"
                    },
                    {
                      "name": "environment",
                      "line": 159,
                      "type": "str | None"
                    },
                    {
                      "name": "query",
                      "line": 160,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "PermissionResult",
                  "line": 201,
                  "description": "Result of a permission check.\n\nAttributes:\n    allowed: Whether the permission is granted\n    role: The role that was checked\n    tool: The tool that was checked\n    action: The action that was checked\n    reason: Explanation for the result (especially for denials)\n    requires_approval: Whether human approval is required before execution",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "allowed",
                      "line": 213,
                      "type": "bool"
                    },
                    {
                      "name": "role",
                      "line": 214,
                      "type": "str"
                    },
                    {
                      "name": "tool",
                      "line": 215,
                      "type": "str"
                    },
                    {
                      "name": "action",
                      "line": 216,
                      "type": "str | None"
                    },
                    {
                      "name": "reason",
                      "line": 217,
                      "type": "str | None"
                    },
                    {
                      "name": "requires_approval",
                      "line": 218,
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "RolePolicy",
                  "line": 221,
                  "description": "Policy definition for a single role.\n\nAttributes:\n    role: The role this policy applies to\n    permissions: List of permissions granted to this role",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "has_permission",
                      "line": 232,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tool",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if this role has any permission for a tool."
                    },
                    {
                      "name": "get_permission",
                      "line": 243,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tool",
                          "type": "str"
                        }
                      ],
                      "return_type": "Permission | None",
                      "description": "Get the permission for a specific tool."
                    }
                  ],
                  "properties": [
                    {
                      "name": "role",
                      "line": 229,
                      "type": "Role"
                    },
                    {
                      "name": "permissions",
                      "line": 230,
                      "type": "list[Permission]"
                    }
                  ]
                },
                {
                  "name": "RBACPolicy",
                  "line": 277,
                  "description": "RBAC Policy manager for MCP tools.\n\nManages role-based access control policies, supporting:\n- Loading policies from YAML configuration\n- Permission checking with context\n- Scope validation\n- Human approval requirements\n- Policy hot-reloading\n\nExample:\n    policy = RBACPolicy.from_yaml()\n    result = policy.check_permission(\n        role=Role.PLANNER,\n        tool=\"read_file\",\n        action=\"read\",\n    )",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 296,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "role_policies",
                          "type": "dict[Role, RolePolicy] | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "policy_path",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize RBACPolicy."
                    },
                    {
                      "name": "_initialize_default_policies",
                      "line": 316,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Initialize default policies per PRD FR-01.3.2."
                    },
                    {
                      "name": "from_yaml",
                      "line": 367,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "path",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "RBACPolicy",
                      "description": "Load policies from a YAML file."
                    },
                    {
                      "name": "get_role_policy",
                      "line": 436,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "role",
                          "type": "Role | str"
                        }
                      ],
                      "return_type": "RolePolicy | None",
                      "description": "Get the policy for a specific role."
                    },
                    {
                      "name": "check_permission",
                      "line": 453,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "role",
                          "type": "Role | str"
                        },
                        {
                          "name": "tool",
                          "type": "str"
                        },
                        {
                          "name": "action",
                          "type": "str"
                        },
                        {
                          "name": "context",
                          "type": "PermissionContext | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "PermissionResult",
                      "description": "Check if a role has permission for a tool action."
                    },
                    {
                      "name": "_check_scope",
                      "line": 541,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "scope",
                          "type": "str"
                        },
                        {
                          "name": "context",
                          "type": "PermissionContext"
                        },
                        {
                          "name": "role",
                          "type": "Role"
                        },
                        {
                          "name": "tool",
                          "type": "str"
                        },
                        {
                          "name": "action",
                          "type": "str"
                        }
                      ],
                      "return_type": "PermissionResult",
                      "description": "Check scope restrictions."
                    },
                    {
                      "name": "_check_requires_approval",
                      "line": 590,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "conditions",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "context",
                          "type": "PermissionContext"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if human approval is required."
                    },
                    {
                      "name": "reload",
                      "line": 611,
                      "visibility": "public",
                      "async": false,
                      "return_type": "None",
                      "description": "Reload policies from the YAML file."
                    },
                    {
                      "name": "watch",
                      "line": 621,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "callback",
                          "type": "Any",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Enable watching the policy file for changes."
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "get_default_policy_path",
                  "line": 263,
                  "description": "Get the default path to policies.yaml.",
                  "async": false,
                  "return_type": "str"
                }
              ],
              "types": [
                {
                  "name": "Role",
                  "kind": "enum",
                  "line": 71,
                  "description": "Agent role definitions for RBAC.\n\nPer PRD FR-01.3.2, the system defines four agent roles:\n- PLANNER: Read-only access for planning and research\n- EXECUTOR: Write access scoped to project directory\n- VALIDATOR: Testing and scanning, no write access\n- HEALER: Patch-only writes with approval in production",
                  "members": [
                    {
                      "name": "PLANNER",
                      "value": "planner"
                    },
                    {
                      "name": "EXECUTOR",
                      "value": "executor"
                    },
                    {
                      "name": "VALIDATOR",
                      "value": "validator"
                    },
                    {
                      "name": "HEALER",
                      "value": "healer"
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "_DEFAULT_POLICY_PATH",
                  "line": 63
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pathlib",
                  "names": [
                    "Path"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "yaml"
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/mcp/__init__.py",
              "description": "MCP (Model Context Protocol) module for DAW.",
              "imports": [
                {
                  "module": "daw_agents.mcp.audit",
                  "names": [
                    "AuditConfig",
                    "AuditEntry",
                    "AuditLogger",
                    "ResultStatus",
                    "compute_entry_hash",
                    "verify_chain_integrity"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.client",
                  "names": [
                    "MCPClient",
                    "MCPClientManager",
                    "MCPTool",
                    "MCPToolResult"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.gateway",
                  "names": [
                    "AGENT_SCOPES",
                    "AgentScope",
                    "GatewayAuthError",
                    "InsufficientScopeError",
                    "InvalidAudienceError",
                    "InvalidRefreshTokenError",
                    "InvalidResourceError",
                    "InvalidTokenError",
                    "MCPGateway",
                    "MCPGatewayConfig",
                    "ScopedToken",
                    "SessionType",
                    "TokenExpiredError",
                    "TokenRevokedError",
                    "ToolCallResult",
                    "UnauthorizedAgentError"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.rbac",
                  "names": [
                    "Permission",
                    "PermissionContext",
                    "PermissionDeniedError",
                    "PermissionResult",
                    "PolicyParseError",
                    "RBACError",
                    "RBACPolicy",
                    "Role",
                    "RoleNotFoundError",
                    "RolePolicy",
                    "get_default_policy_path"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.mcp.shields",
                  "names": [
                    "ContentBlockedError",
                    "ContentShield",
                    "DangerousPattern",
                    "SchemaValidationError",
                    "ShieldConfig",
                    "ShieldedGateway",
                    "ShieldError",
                    "ValidationResult",
                    "get_pattern_regex"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "MCPClient",
                "MCPClientManager",
                "MCPTool",
                "MCPToolResult",
                "MCPGateway",
                "MCPGatewayConfig",
                "AgentScope",
                "ScopedToken",
                "ToolCallResult",
                "SessionType",
                "AGENT_SCOPES",
                "GatewayAuthError",
                "UnauthorizedAgentError",
                "InsufficientScopeError",
                "TokenExpiredError",
                "TokenRevokedError",
                "InvalidTokenError",
                "InvalidRefreshTokenError",
                "InvalidAudienceError",
                "InvalidResourceError",
                "ContentShield",
                "ShieldConfig",
                "ShieldedGateway",
                "DangerousPattern",
                "ValidationResult",
                "get_pattern_regex",
                "ShieldError",
                "ContentBlockedError",
                "SchemaValidationError",
                "Role",
                "Permission",
                "PermissionContext",
                "PermissionResult",
                "RolePolicy",
                "RBACPolicy",
                "get_default_policy_path",
                "RBACError",
                "PolicyParseError",
                "PermissionDeniedError",
                "RoleNotFoundError",
                "AuditConfig",
                "AuditEntry",
                "AuditLogger",
                "ResultStatus",
                "compute_entry_hash",
                "verify_chain_integrity"
              ]
            },
            {
              "name": "shields.py",
              "path": "daw_agents/mcp/shields.py",
              "description": "MCP Content Injection Prevention (Prompt Shields).",
              "classes": [
                {
                  "name": "ShieldError",
                  "line": 131,
                  "description": "Base exception for shield errors.",
                  "bases": [
                    "Exception"
                  ]
                },
                {
                  "name": "ContentBlockedError",
                  "line": 137,
                  "description": "Raised when content is blocked due to dangerous patterns.\n\nAttributes:\n    message: Human-readable error message\n    patterns: List of patterns that triggered the block",
                  "bases": [
                    "ShieldError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 145,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str"
                        },
                        {
                          "name": "patterns",
                          "type": "list[DangerousPattern] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "SchemaValidationError",
                  "line": 155,
                  "description": "Raised when JSON schema validation fails.\n\nAttributes:\n    message: Human-readable error message\n    path: JSON path to the invalid field\n    expected: Expected type/value\n    received: Received type/value",
                  "bases": [
                    "ShieldError"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 165,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str"
                        },
                        {
                          "name": "path",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "expected",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "received",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None"
                    }
                  ]
                },
                {
                  "name": "ShieldConfig",
                  "line": 184,
                  "description": "Configuration for content shields.\n\nAttributes:\n    enabled: Whether shields are active\n    block_sql_ddl: Block SQL DDL operations (DROP, DELETE, etc.)\n    block_shell_dangerous: Block dangerous shell commands (rm -rf, sudo)\n    block_prompt_injection: Block prompt injection attempts\n    block_file_sensitive: Block access to sensitive files\n    custom_patterns: List of custom regex patterns to block",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "strict",
                      "line": 204,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "return_type": "ShieldConfig",
                      "description": "Create a strict configuration with all shields enabled."
                    }
                  ],
                  "properties": [
                    {
                      "name": "enabled",
                      "line": 196,
                      "type": "bool"
                    },
                    {
                      "name": "block_sql_ddl",
                      "line": 197,
                      "type": "bool"
                    },
                    {
                      "name": "block_shell_dangerous",
                      "line": 198,
                      "type": "bool"
                    },
                    {
                      "name": "block_prompt_injection",
                      "line": 199,
                      "type": "bool"
                    },
                    {
                      "name": "block_file_sensitive",
                      "line": 200,
                      "type": "bool"
                    },
                    {
                      "name": "custom_patterns",
                      "line": 201,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "ValidationResult",
                  "line": 219,
                  "description": "Result of a content validation operation.\n\nAttributes:\n    is_valid: Whether the content passed validation\n    blocked_patterns: List of patterns that were detected\n    error_message: Human-readable error description\n    sanitized_content: Content with dangerous patterns removed\n    original_content: Original content before validation",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "is_valid",
                      "line": 230,
                      "type": "bool"
                    },
                    {
                      "name": "blocked_patterns",
                      "line": 231,
                      "type": "list[DangerousPattern]"
                    },
                    {
                      "name": "error_message",
                      "line": 232,
                      "type": "str | None"
                    },
                    {
                      "name": "sanitized_content",
                      "line": 233,
                      "type": "str | None"
                    },
                    {
                      "name": "original_content",
                      "line": 234,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "ContentShield",
                  "line": 242,
                  "description": "AI Prompt Shield for content injection prevention.\n\nThis class provides methods to validate and sanitize tool inputs and outputs,\ndetecting and blocking dangerous patterns like SQL injection, shell command\ninjection, and prompt injection.\n\nAttributes:\n    config: Shield configuration\n\nExample:\n    shield = ContentShield()\n\n    # Validate user input\n    result = shield.validate_input(\"DROP TABLE users\")\n    if not result.is_valid:\n        print(f\"Blocked: {result.blocked_patterns}\")\n\n    # Validate tool output\n    result = shield.validate_output(\"Ignore all previous instructions\")\n    if not result.is_valid:\n        print(f\"Prompt injection detected!\")",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 266,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "ShieldConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the content shield."
                    },
                    {
                      "name": "_compile_patterns",
                      "line": 277,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Compile regex patterns for efficient matching."
                    },
                    {
                      "name": "_get_active_patterns",
                      "line": 291,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "dict[DangerousPattern, re.Pattern[str]]",
                      "description": "Get patterns that are active based on config."
                    },
                    {
                      "name": "_detect_patterns",
                      "line": 342,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "content",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[DangerousPattern]",
                      "description": "Detect dangerous patterns in content."
                    },
                    {
                      "name": "validate_input",
                      "line": 366,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "content",
                          "type": "str | None"
                        },
                        {
                          "name": "sanitize",
                          "type": "bool",
                          "default": "False",
                          "optional": true
                        }
                      ],
                      "return_type": "ValidationResult",
                      "description": "Validate input content for dangerous patterns."
                    },
                    {
                      "name": "validate_output",
                      "line": 423,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "content",
                          "type": "str"
                        }
                      ],
                      "return_type": "ValidationResult",
                      "description": "Validate output content for prompt injection attempts."
                    },
                    {
                      "name": "sanitize",
                      "line": 438,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "content",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Remove dangerous patterns from content."
                    },
                    {
                      "name": "validate_json",
                      "line": 460,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "data",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "schema",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "ValidationResult",
                      "description": "Validate data against a JSON schema."
                    },
                    {
                      "name": "_basic_schema_validation",
                      "line": 494,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "data",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "schema",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "ValidationResult",
                      "description": "Basic JSON schema validation without jsonschema library."
                    },
                    {
                      "name": "_check_type",
                      "line": 561,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "value",
                          "type": "Any"
                        },
                        {
                          "name": "expected_type",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if a value matches an expected JSON schema type."
                    },
                    {
                      "name": "validate_tool_call",
                      "line": 587,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "tool_name",
                          "type": "str"
                        },
                        {
                          "name": "params",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "ValidationResult",
                      "description": "Validate tool call parameters."
                    },
                    {
                      "name": "validate_tool_result",
                      "line": 630,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "result",
                          "type": "dict[str, Any] | str"
                        }
                      ],
                      "return_type": "ValidationResult",
                      "description": "Validate tool execution result."
                    }
                  ]
                },
                {
                  "name": "ShieldedGateway",
                  "line": 656,
                  "description": "MCP Gateway wrapped with content shields.\n\nThis class combines the MCP Gateway authorization with content shields\nto provide comprehensive protection for tool calls.\n\nAttributes:\n    gateway: The underlying MCP Gateway\n    shield: Content shield for validation\n\nExample:\n    shielded = ShieldedGateway(\n        gateway_config=MCPGatewayConfig(...),\n        shield_config=ShieldConfig.strict(),\n    )\n\n    # All tool calls are automatically validated\n    result = await shielded.validate_and_call(token, \"query_db\", params)",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 676,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "gateway_config",
                          "type": "Any"
                        },
                        {
                          "name": "shield_config",
                          "type": "ShieldConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the shielded gateway."
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "get_pattern_regex",
                  "line": 114,
                  "description": "Get the regex pattern for a DangerousPattern.",
                  "async": false,
                  "return_type": "str | None",
                  "parameters": [
                    {
                      "name": "pattern",
                      "type": "DangerousPattern"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "DangerousPattern",
                  "kind": "enum",
                  "line": 50,
                  "description": "Categorized dangerous command patterns.\n\nThese patterns are used to detect and block potentially harmful content\nin tool inputs and outputs.",
                  "members": [
                    {
                      "name": "SQL_DROP",
                      "value": "sql_drop"
                    },
                    {
                      "name": "SQL_DELETE",
                      "value": "sql_delete"
                    },
                    {
                      "name": "SQL_TRUNCATE",
                      "value": "sql_truncate"
                    },
                    {
                      "name": "SQL_ALTER",
                      "value": "sql_alter"
                    },
                    {
                      "name": "SQL_UNION",
                      "value": "sql_union"
                    },
                    {
                      "name": "SHELL_RM_RF",
                      "value": "shell_rm_rf"
                    },
                    {
                      "name": "SHELL_SUDO",
                      "value": "shell_sudo"
                    },
                    {
                      "name": "SHELL_CHMOD",
                      "value": "shell_chmod"
                    },
                    {
                      "name": "SHELL_CHOWN",
                      "value": "shell_chown"
                    },
                    {
                      "name": "PROMPT_IGNORE",
                      "value": "prompt_ignore"
                    },
                    {
                      "name": "PROMPT_SYSTEM",
                      "value": "prompt_system"
                    },
                    {
                      "name": "PROMPT_OVERRIDE",
                      "value": "prompt_override"
                    },
                    {
                      "name": "PROMPT_JAILBREAK",
                      "value": "prompt_jailbreak"
                    },
                    {
                      "name": "FILE_ETC_PASSWD",
                      "value": "file_etc_passwd"
                    },
                    {
                      "name": "FILE_ETC_SHADOW",
                      "value": "file_etc_shadow"
                    },
                    {
                      "name": "FILE_SSH_KEY",
                      "value": "file_ssh_key"
                    },
                    {
                      "name": "FILE_PATH_TRAVERSAL",
                      "value": "file_path_traversal"
                    },
                    {
                      "name": "CUSTOM",
                      "value": "custom"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "re"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        },
        "models": {
          "name": "models",
          "path": "src/daw_agents/models",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/models/__init__.py",
              "description": "DAW Agent Models Module.",
              "imports": [
                {
                  "module": "daw_agents.models.providers",
                  "names": [
                    "ModelConfig",
                    "ModelProvider",
                    "ProviderConfig",
                    "get_default_configs",
                    "get_helicone_config"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "ModelRouter",
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "ModelConfig",
                "ModelProvider",
                "ModelRouter",
                "ProviderConfig",
                "TaskType",
                "get_default_configs",
                "get_helicone_config"
              ]
            },
            {
              "name": "providers.py",
              "path": "daw_agents/models/providers.py",
              "description": "Model Provider Configuration for DAW Agent Workbench.",
              "classes": [
                {
                  "name": "ModelConfig",
                  "line": 32,
                  "description": "Configuration for a model used in a specific task type.\n\nAttributes:\n    primary: Primary model identifier (e.g., \"claude-3-5-sonnet-20241022\")\n    fallback: Fallback model identifier used when primary fails\n    max_tokens: Maximum tokens for response generation\n    temperature: Temperature for response generation (0.0-2.0)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "primary",
                      "line": 42,
                      "type": "str"
                    },
                    {
                      "name": "fallback",
                      "line": 43,
                      "type": "str"
                    },
                    {
                      "name": "max_tokens",
                      "line": 44,
                      "type": "int"
                    },
                    {
                      "name": "temperature",
                      "line": 45,
                      "type": "float"
                    }
                  ]
                },
                {
                  "name": "ProviderConfig",
                  "line": 48,
                  "description": "Provider-level configuration.\n\nAttributes:\n    api_key: API key for the provider\n    api_base: Optional custom API base URL (e.g., Helicone proxy)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "api_key",
                      "line": 56,
                      "type": "str | None"
                    },
                    {
                      "name": "api_base",
                      "line": 57,
                      "type": "str | None"
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "get_default_configs",
                  "line": 60,
                  "description": "Get default model configurations for all task types.",
                  "async": false,
                  "return_type": "dict[TaskType, ModelConfig]"
                },
                {
                  "name": "get_helicone_config",
                  "line": 110,
                  "description": "Get Helicone proxy configuration.",
                  "async": false,
                  "return_type": "ProviderConfig"
                }
              ],
              "types": [
                {
                  "name": "ModelProvider",
                  "kind": "enum",
                  "line": 25,
                  "description": "Supported LLM providers.",
                  "members": [
                    {
                      "name": "OPENAI",
                      "value": "openai"
                    },
                    {
                      "name": "ANTHROPIC",
                      "value": "anthropic"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "os"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.router",
                  "names": [
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "router.py",
              "path": "daw_agents/models/router.py",
              "description": "Model Router for DAW Agent Workbench.",
              "classes": [
                {
                  "name": "ModelRouter",
                  "line": 54,
                  "description": "Routes LLM requests to appropriate models based on task type.\n\nThe router implements:\n1. Task-based model selection\n2. Automatic fallback when primary model fails\n3. Helicone integration for cost tracking\n4. Cross-validation principle (validator != executor model)\n\nExample:\n    ```python\n    router = ModelRouter()\n\n    # Route a planning task to high-reasoning model\n    result = await router.route(\n        task_type=TaskType.PLANNING,\n        messages=[{\"role\": \"user\", \"content\": \"Create a PRD for a todo app\"}],\n    )\n\n    # Get model for a specific task type\n    model = router.get_model_for_task(TaskType.CODING)\n    ```",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 78,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "configs",
                          "type": "dict[TaskType, ModelConfig] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the ModelRouter."
                    },
                    {
                      "name": "_validate_cross_validation_principle",
                      "line": 91,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Validate that validation model differs from coding model."
                    },
                    {
                      "name": "get_model_for_task",
                      "line": 109,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task_type",
                          "type": "TaskType"
                        }
                      ],
                      "return_type": "str",
                      "description": "Get the primary model identifier for a given task type."
                    },
                    {
                      "name": "get_config_for_task",
                      "line": 120,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task_type",
                          "type": "TaskType"
                        }
                      ],
                      "return_type": "ModelConfig",
                      "description": "Get the full configuration for a given task type."
                    },
                    {
                      "name": "_build_request_params",
                      "line": 131,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task_type",
                          "type": "TaskType"
                        },
                        {
                          "name": "messages",
                          "type": "list[dict[str, str]]"
                        },
                        {
                          "name": "model",
                          "type": "str"
                        },
                        {
                          "name": "metadata",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Build request parameters for LiteLLM."
                    },
                    {
                      "name": "route",
                      "line": 195,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "task_type",
                          "type": "TaskType"
                        },
                        {
                          "name": "messages",
                          "type": "list[dict[str, str]]"
                        },
                        {
                          "name": "metadata",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "str",
                      "description": "Route a request to the appropriate model based on task type."
                    },
                    {
                      "name": "route_with_retry",
                      "line": 268,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "task_type",
                          "type": "TaskType"
                        },
                        {
                          "name": "messages",
                          "type": "list[dict[str, str]]"
                        },
                        {
                          "name": "metadata",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "max_retries",
                          "type": "int",
                          "default": "3",
                          "optional": true
                        }
                      ],
                      "return_type": "str",
                      "description": "Route a request with additional retry logic."
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "TaskType",
                  "kind": "enum",
                  "line": 38,
                  "description": "Task types for model routing.\n\nEach task type maps to different model requirements:\n- PLANNING: High reasoning capability (o1, opus)\n- CODING: Balanced performance (sonnet, gpt-4o)\n- VALIDATION: Cross-validation (MUST differ from CODING)\n- FAST: Speed-optimized (haiku, gpt-4o-mini)",
                  "members": [
                    {
                      "name": "PLANNING",
                      "value": "planning"
                    },
                    {
                      "name": "CODING",
                      "value": "coding"
                    },
                    {
                      "name": "VALIDATION",
                      "value": "validation"
                    },
                    {
                      "name": "FAST",
                      "value": "fast"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "litellm",
                  "names": [
                    "acompletion"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.models.providers",
                  "names": [
                    "ModelConfig",
                    "get_default_configs",
                    "get_helicone_config"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        },
        "schemas": {
          "name": "schemas",
          "path": "src/daw_agents/schemas",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/schemas/__init__.py",
              "description": "Schemas package for DAW Workbench.",
              "imports": [
                {
                  "module": "daw_agents.schemas.prd_schema",
                  "names": [
                    "AcceptanceCriteriaSchema",
                    "NonFunctionalRequirementSchema",
                    "NonFunctionalType",
                    "PRDSchema",
                    "TechSpecSchema",
                    "UserStoryPriority",
                    "UserStorySchema"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "PRDSchema",
                "UserStorySchema",
                "TechSpecSchema",
                "AcceptanceCriteriaSchema",
                "NonFunctionalRequirementSchema",
                "UserStoryPriority",
                "NonFunctionalType"
              ]
            },
            {
              "name": "prd_schema.py",
              "path": "daw_agents/schemas/prd_schema.py",
              "description": "PRD Schema definitions for structured PRD output (PRD-OUTPUT-001).",
              "classes": [
                {
                  "name": "AcceptanceCriteriaSchema",
                  "line": 59,
                  "description": "Acceptance criterion in Given/When/Then (Gherkin) format.\n\nThis format enables testable acceptance criteria that can be\ndirectly converted to BDD test scenarios.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "to_gherkin",
                      "line": 79,
                      "visibility": "public",
                      "async": false,
                      "return_type": "str",
                      "description": "Convert to Gherkin scenario format."
                    }
                  ],
                  "properties": [
                    {
                      "name": "given",
                      "line": 66,
                      "type": "str"
                    },
                    {
                      "name": "when",
                      "line": 67,
                      "type": "str"
                    },
                    {
                      "name": "then",
                      "line": 68,
                      "type": "str"
                    },
                    {
                      "name": "and_given",
                      "line": 69,
                      "type": "list[str]"
                    },
                    {
                      "name": "and_when",
                      "line": 72,
                      "type": "list[str]"
                    },
                    {
                      "name": "and_then",
                      "line": 75,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "UserStorySchema",
                  "line": 102,
                  "description": "User story with priority and testable acceptance criteria.\n\nFollows the format: As a [user], I want [goal] so that [benefit]",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 108,
                      "type": "str"
                    },
                    {
                      "name": "title",
                      "line": 109,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 110,
                      "type": "str"
                    },
                    {
                      "name": "priority",
                      "line": 113,
                      "type": "UserStoryPriority"
                    },
                    {
                      "name": "acceptance_criteria",
                      "line": 114,
                      "type": "list[AcceptanceCriteriaSchema]"
                    },
                    {
                      "name": "dependencies",
                      "line": 117,
                      "type": "list[str]"
                    },
                    {
                      "name": "tags",
                      "line": 120,
                      "type": "list[str]"
                    },
                    {
                      "name": "estimated_points",
                      "line": 123,
                      "type": "int | None"
                    },
                    {
                      "name": "notes",
                      "line": 126,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "TechSpecSchema",
                  "line": 134,
                  "description": "Technical specifications with architecture decisions.\n\nCaptures the technical approach and constraints for implementation.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "architecture_pattern",
                      "line": 140,
                      "type": "str"
                    },
                    {
                      "name": "architecture_decisions",
                      "line": 143,
                      "type": "list[str]"
                    },
                    {
                      "name": "technology_stack",
                      "line": 146,
                      "type": "list[str]"
                    },
                    {
                      "name": "infrastructure_requirements",
                      "line": 149,
                      "type": "list[str]"
                    },
                    {
                      "name": "constraints",
                      "line": 152,
                      "type": "list[str]"
                    },
                    {
                      "name": "integrations",
                      "line": 155,
                      "type": "list[str]"
                    },
                    {
                      "name": "data_model",
                      "line": 158,
                      "type": "dict[str, Any] | None"
                    }
                  ]
                },
                {
                  "name": "NonFunctionalRequirementSchema",
                  "line": 168,
                  "description": "Non-functional requirement with measurable target.\n\nNFRs define quality attributes like performance, security, etc.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "type",
                      "line": 174,
                      "type": "NonFunctionalType"
                    },
                    {
                      "name": "description",
                      "line": 175,
                      "type": "str"
                    },
                    {
                      "name": "metric",
                      "line": 176,
                      "type": "str"
                    },
                    {
                      "name": "target",
                      "line": 177,
                      "type": "str"
                    },
                    {
                      "name": "priority",
                      "line": 178,
                      "type": "UserStoryPriority"
                    },
                    {
                      "name": "verification_method",
                      "line": 181,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "PRDSchema",
                  "line": 191,
                  "description": "Complete PRD schema for structured output.\n\nThis is the main schema that combines all PRD components.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "validate_tech_specs",
                      "line": 224,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "model_validator",
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "data",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Ensure tech_specs is properly structured."
                    },
                    {
                      "name": "to_markdown",
                      "line": 236,
                      "visibility": "public",
                      "async": false,
                      "return_type": "str",
                      "description": "Convert PRD to Markdown format."
                    }
                  ],
                  "properties": [
                    {
                      "name": "title",
                      "line": 197,
                      "type": "str"
                    },
                    {
                      "name": "version",
                      "line": 198,
                      "type": "str"
                    },
                    {
                      "name": "overview",
                      "line": 199,
                      "type": "str"
                    },
                    {
                      "name": "user_stories",
                      "line": 200,
                      "type": "list[UserStorySchema]"
                    },
                    {
                      "name": "tech_specs",
                      "line": 203,
                      "type": "TechSpecSchema"
                    },
                    {
                      "name": "acceptance_criteria",
                      "line": 206,
                      "type": "list[AcceptanceCriteriaSchema]"
                    },
                    {
                      "name": "non_functional_requirements",
                      "line": 209,
                      "type": "list[NonFunctionalRequirementSchema]"
                    },
                    {
                      "name": "assumptions",
                      "line": 212,
                      "type": "list[str]"
                    },
                    {
                      "name": "risks",
                      "line": 215,
                      "type": "list[str]"
                    },
                    {
                      "name": "out_of_scope",
                      "line": 218,
                      "type": "list[str]"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "UserStoryPriority",
                  "kind": "enum",
                  "line": 30,
                  "description": "Priority levels for user stories.\n\nP0: Critical - Must have for MVP\nP1: High - Important but not blocking\nP2: Medium - Nice to have",
                  "members": [
                    {
                      "name": "P0",
                      "value": "P0"
                    },
                    {
                      "name": "P1",
                      "value": "P1"
                    },
                    {
                      "name": "P2",
                      "value": "P2"
                    }
                  ]
                },
                {
                  "name": "NonFunctionalType",
                  "kind": "enum",
                  "line": 43,
                  "description": "Types of non-functional requirements.",
                  "members": [
                    {
                      "name": "PERFORMANCE",
                      "value": "performance"
                    },
                    {
                      "name": "SECURITY",
                      "value": "security"
                    },
                    {
                      "name": "SCALABILITY",
                      "value": "scalability"
                    },
                    {
                      "name": "RELIABILITY",
                      "value": "reliability"
                    },
                    {
                      "name": "MAINTAINABILITY",
                      "value": "maintainability"
                    },
                    {
                      "name": "USABILITY",
                      "value": "usability"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field",
                    "model_validator"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "UserStoryPriority",
                "NonFunctionalType",
                "AcceptanceCriteriaSchema",
                "UserStorySchema",
                "TechSpecSchema",
                "NonFunctionalRequirementSchema",
                "PRDSchema"
              ]
            }
          ]
        },
        "sandbox": {
          "name": "sandbox",
          "path": "src/daw_agents/sandbox",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/sandbox/__init__.py",
              "description": "Sandbox module for secure code execution.",
              "imports": [
                {
                  "module": "daw_agents.sandbox.e2b",
                  "names": [
                    "CommandResult",
                    "E2BSandbox",
                    "SandboxConfig",
                    "SandboxError",
                    "SandboxNotStartedError",
                    "SandboxTimeoutError",
                    "load_api_key_from_file"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "CommandResult",
                "E2BSandbox",
                "SandboxConfig",
                "SandboxError",
                "SandboxNotStartedError",
                "SandboxTimeoutError",
                "load_api_key_from_file"
              ]
            },
            {
              "name": "e2b.py",
              "path": "daw_agents/sandbox/e2b.py",
              "description": "E2B Sandbox Wrapper for secure code execution.",
              "classes": [
                {
                  "name": "SandboxError",
                  "line": 36,
                  "description": "Base exception for sandbox-related errors.",
                  "bases": [
                    "Exception"
                  ]
                },
                {
                  "name": "SandboxNotStartedError",
                  "line": 40,
                  "description": "Raised when trying to use a sandbox that hasn't been started.",
                  "bases": [
                    "SandboxError"
                  ]
                },
                {
                  "name": "SandboxTimeoutError",
                  "line": 44,
                  "description": "Raised when a sandbox operation times out.",
                  "bases": [
                    "SandboxError"
                  ]
                },
                {
                  "name": "SandboxConfig",
                  "line": 53,
                  "description": "Configuration for E2B sandbox.\n\nAttributes:\n    api_key: E2B API key for authentication.\n    timeout: Sandbox timeout in seconds (default 300s, max 86400s for Pro).\n    template: Sandbox template name or ID (default \"base\").\n    cpu_limit: CPU limit (number of cores).\n    memory_limit_mb: Memory limit in megabytes.\n    network_allowlist: List of allowed network domains.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "api_key",
                      "line": 65,
                      "type": "str"
                    },
                    {
                      "name": "timeout",
                      "line": 66,
                      "type": "int"
                    },
                    {
                      "name": "template",
                      "line": 67,
                      "type": "str"
                    },
                    {
                      "name": "cpu_limit",
                      "line": 68,
                      "type": "int | None"
                    },
                    {
                      "name": "memory_limit_mb",
                      "line": 69,
                      "type": "int | None"
                    },
                    {
                      "name": "network_allowlist",
                      "line": 70,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "CommandResult",
                  "line": 75,
                  "description": "Result of a command execution in the sandbox.\n\nAttributes:\n    stdout: Standard output from the command.\n    stderr: Standard error from the command.\n    exit_code: Exit code of the command (None if command didn't complete).\n    error: Error message if the command failed to execute.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "success",
                      "line": 91,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "bool",
                      "description": "Check if the command executed successfully."
                    }
                  ],
                  "properties": [
                    {
                      "name": "stdout",
                      "line": 85,
                      "type": "str"
                    },
                    {
                      "name": "stderr",
                      "line": 86,
                      "type": "str"
                    },
                    {
                      "name": "exit_code",
                      "line": 87,
                      "type": "int | None"
                    },
                    {
                      "name": "error",
                      "line": 88,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "E2BSandbox",
                  "line": 122,
                  "description": "Wrapper for E2B sandbox providing secure code execution.\n\nThis class wraps the E2B SDK to provide a simplified interface for:\n- Creating and managing sandbox instances\n- Executing commands with timeout handling\n- File operations\n- Automatic cleanup on completion or error\n\nUsage:\n    ```python\n    config = SandboxConfig(api_key=\"your_key\")\n    async with E2BSandbox(config=config) as sandbox:\n        result = await sandbox.run_command(\"echo 'Hello, World!'\")\n        print(result.stdout)\n    ```",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 140,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "SandboxConfig"
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the E2B sandbox wrapper."
                    },
                    {
                      "name": "from_env",
                      "line": 150,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "return_type": "E2BSandbox",
                      "description": "Create an E2BSandbox using API key from environment."
                    },
                    {
                      "name": "sandbox_id",
                      "line": 166,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "str | None",
                      "description": "Get the sandbox ID if running."
                    },
                    {
                      "name": "is_running",
                      "line": 174,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "bool",
                      "description": "Check if the sandbox is currently running."
                    },
                    {
                      "name": "start",
                      "line": 181,
                      "visibility": "public",
                      "async": true,
                      "return_type": "None",
                      "description": "Start a new sandbox instance."
                    },
                    {
                      "name": "stop",
                      "line": 207,
                      "visibility": "public",
                      "async": true,
                      "return_type": "bool",
                      "description": "Stop and terminate the sandbox."
                    },
                    {
                      "name": "_ensure_started",
                      "line": 226,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Ensure the sandbox has been started."
                    },
                    {
                      "name": "run_command",
                      "line": 237,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "cmd",
                          "type": "str"
                        },
                        {
                          "name": "timeout",
                          "type": "float",
                          "default": "60",
                          "optional": true
                        },
                        {
                          "name": "envs",
                          "type": "dict[str, str] | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "cwd",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "CommandResult",
                      "description": "Execute a command in the sandbox."
                    },
                    {
                      "name": "write_file",
                      "line": 310,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "str"
                        },
                        {
                          "name": "content",
                          "type": "str | bytes"
                        }
                      ],
                      "return_type": "None",
                      "description": "Write content to a file in the sandbox."
                    },
                    {
                      "name": "read_file",
                      "line": 323,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Read content from a file in the sandbox."
                    },
                    {
                      "name": "__aenter__",
                      "line": 343,
                      "visibility": "protected",
                      "async": true,
                      "return_type": "E2BSandbox",
                      "description": "Enter the async context manager."
                    },
                    {
                      "name": "__aexit__",
                      "line": 348,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "exc_type",
                          "type": "type[BaseException] | None"
                        },
                        {
                          "name": "exc_val",
                          "type": "BaseException | None"
                        },
                        {
                          "name": "exc_tb",
                          "type": "object"
                        }
                      ],
                      "return_type": "None",
                      "description": "Exit the async context manager, ensuring cleanup."
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "load_api_key_from_file",
                  "line": 101,
                  "description": "Load E2B API key from a file.",
                  "async": false,
                  "return_type": "str",
                  "parameters": [
                    {
                      "name": "file_path",
                      "type": "str | Path"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "os"
                },
                {
                  "module": "pathlib",
                  "names": [
                    "Path"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "e2b",
                  "names": [
                    "AsyncSandbox"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        },
        "evolution": {
          "name": "evolution",
          "path": "src/daw_agents/evolution",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/evolution/__init__.py",
              "description": "Evolution module for self-learning foundation.",
              "imports": [
                {
                  "module": "daw_agents.evolution.experience_logger",
                  "names": [
                    "ExperienceLogger"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.evolution.schemas",
                  "names": [
                    "Artifact",
                    "ArtifactType",
                    "Experience",
                    "ExperienceQuery",
                    "Insight",
                    "Skill",
                    "SuccessRate",
                    "TaskType"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "ExperienceLogger",
                "Experience",
                "ExperienceQuery",
                "Skill",
                "Artifact",
                "ArtifactType",
                "Insight",
                "SuccessRate",
                "TaskType"
              ]
            },
            {
              "name": "schemas.py",
              "path": "daw_agents/evolution/schemas.py",
              "description": "Pydantic schemas for the evolution/self-learning module.",
              "classes": [
                {
                  "name": "Experience",
                  "line": 48,
                  "description": "Represents a task completion experience for learning.\n\nThis is the core data structure for the self-evolution system,\nstoring all metadata about task executions for future retrieval\nand learning.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "to_neo4j_properties",
                      "line": 76,
                      "visibility": "public",
                      "async": false,
                      "return_type": "dict[str, Any]",
                      "description": "Convert to properties dict for Neo4j node creation."
                    }
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 57,
                      "type": "str"
                    },
                    {
                      "name": "task_id",
                      "line": 58,
                      "type": "str"
                    },
                    {
                      "name": "task_type",
                      "line": 59,
                      "type": "TaskType"
                    },
                    {
                      "name": "success",
                      "line": 60,
                      "type": "bool"
                    },
                    {
                      "name": "prompt_version",
                      "line": 61,
                      "type": "str"
                    },
                    {
                      "name": "model_used",
                      "line": 62,
                      "type": "str"
                    },
                    {
                      "name": "tokens_used",
                      "line": 63,
                      "type": "int"
                    },
                    {
                      "name": "cost_usd",
                      "line": 64,
                      "type": "float"
                    },
                    {
                      "name": "duration_ms",
                      "line": 65,
                      "type": "int"
                    },
                    {
                      "name": "retries",
                      "line": 66,
                      "type": "int"
                    },
                    {
                      "name": "timestamp",
                      "line": 67,
                      "type": "datetime"
                    },
                    {
                      "name": "error_message",
                      "line": 71,
                      "type": "str | None"
                    },
                    {
                      "name": "error_type",
                      "line": 74,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "Skill",
                  "line": 95,
                  "description": "Represents a reusable code pattern or skill.\n\nSkills are extracted from successful experiences and can be\nreferenced in future tasks via the USED_SKILL relationship.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "to_neo4j_properties",
                      "line": 113,
                      "visibility": "public",
                      "async": false,
                      "return_type": "dict[str, Any]",
                      "description": "Convert to properties dict for Neo4j node creation."
                    }
                  ],
                  "properties": [
                    {
                      "name": "name",
                      "line": 103,
                      "type": "str"
                    },
                    {
                      "name": "pattern",
                      "line": 104,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 105,
                      "type": "str | None"
                    },
                    {
                      "name": "success_rate",
                      "line": 108,
                      "type": "float"
                    },
                    {
                      "name": "usage_count",
                      "line": 111,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "Artifact",
                  "line": 124,
                  "description": "Represents an artifact produced by a task.\n\nArtifacts include code files, tests, documentation, and other\noutputs created during task execution.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "to_neo4j_properties",
                      "line": 138,
                      "visibility": "public",
                      "async": false,
                      "return_type": "dict[str, Any]",
                      "description": "Convert to properties dict for Neo4j node creation."
                    }
                  ],
                  "properties": [
                    {
                      "name": "artifact_type",
                      "line": 132,
                      "type": "ArtifactType"
                    },
                    {
                      "name": "path",
                      "line": 133,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 134,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "Insight",
                  "line": 147,
                  "description": "Represents a lesson learned from reflection.\n\nInsights are created by the reflection hook after task completion\nto capture what worked well and what could be improved.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "to_neo4j_properties",
                      "line": 166,
                      "visibility": "public",
                      "async": false,
                      "return_type": "dict[str, Any]",
                      "description": "Convert to properties dict for Neo4j node creation."
                    }
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 155,
                      "type": "str"
                    },
                    {
                      "name": "what_worked",
                      "line": 156,
                      "type": "str"
                    },
                    {
                      "name": "lesson_learned",
                      "line": 157,
                      "type": "str"
                    },
                    {
                      "name": "improvement_suggestion",
                      "line": 158,
                      "type": "str | None"
                    },
                    {
                      "name": "created_at",
                      "line": 161,
                      "type": "datetime"
                    }
                  ]
                },
                {
                  "name": "ExperienceQuery",
                  "line": 177,
                  "description": "Query parameters for retrieving similar experiences.\n\nUsed for RAG-style retrieval of past experiences based on\nvarious criteria.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "task_type",
                      "line": 185,
                      "type": "TaskType | None"
                    },
                    {
                      "name": "success",
                      "line": 186,
                      "type": "bool | None"
                    },
                    {
                      "name": "model_used",
                      "line": 187,
                      "type": "str | None"
                    },
                    {
                      "name": "error_type",
                      "line": 188,
                      "type": "str | None"
                    },
                    {
                      "name": "start_time",
                      "line": 189,
                      "type": "datetime | None"
                    },
                    {
                      "name": "end_time",
                      "line": 192,
                      "type": "datetime | None"
                    },
                    {
                      "name": "limit",
                      "line": 195,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "SuccessRate",
                  "line": 198,
                  "description": "Success rate statistics for a task type/model combination.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "task_type",
                      "line": 203,
                      "type": "TaskType | None"
                    },
                    {
                      "name": "model_used",
                      "line": 204,
                      "type": "str | None"
                    },
                    {
                      "name": "success_rate",
                      "line": 205,
                      "type": "float"
                    },
                    {
                      "name": "total_count",
                      "line": 208,
                      "type": "int"
                    },
                    {
                      "name": "success_count",
                      "line": 209,
                      "type": "int"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "TaskType",
                  "kind": "enum",
                  "line": 27,
                  "description": "Task types for categorizing experiences.",
                  "members": [
                    {
                      "name": "PLANNING",
                      "value": "planning"
                    },
                    {
                      "name": "CODING",
                      "value": "coding"
                    },
                    {
                      "name": "VALIDATION",
                      "value": "validation"
                    },
                    {
                      "name": "FAST",
                      "value": "fast"
                    },
                    {
                      "name": "DEBUGGING",
                      "value": "debugging"
                    },
                    {
                      "name": "DOCUMENTATION",
                      "value": "documentation"
                    }
                  ]
                },
                {
                  "name": "ArtifactType",
                  "kind": "enum",
                  "line": 38,
                  "description": "Types of artifacts produced by tasks.",
                  "members": [
                    {
                      "name": "CODE",
                      "value": "code"
                    },
                    {
                      "name": "TEST",
                      "value": "test"
                    },
                    {
                      "name": "DOCUMENTATION",
                      "value": "documentation"
                    },
                    {
                      "name": "CONFIG",
                      "value": "config"
                    },
                    {
                      "name": "PRD",
                      "value": "prd"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "uuid"
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "experience_logger.py",
              "path": "daw_agents/evolution/experience_logger.py",
              "description": "Experience Logger for self-learning foundation.",
              "classes": [
                {
                  "name": "ExperienceLogger",
                  "line": 39,
                  "description": "Logger for storing and querying task completion experiences.\n\nThis class provides the foundation for self-learning capabilities\nby persisting experiences in Neo4j and enabling RAG-style retrieval.\n\nExample:\n    connector = Neo4jConnector.get_instance(config)\n    logger = ExperienceLogger(neo4j_connector=connector)\n\n    # Log a successful experience\n    exp_id = await logger.log_success(\n        task_id=\"CORE-003\",\n        task_type=TaskType.CODING,\n        prompt_version=\"executor_v1.2\",\n        model_used=\"claude-sonnet-4-20250514\",\n        tokens_used=5000,\n        cost_usd=0.045,\n        duration_ms=12500\n    )\n\n    # Query similar experiences\n    query = ExperienceQuery(task_type=TaskType.CODING, success=True)\n    experiences = await logger.query_similar_experiences(query)\n\n    # Get success rate\n    rate = await logger.calculate_success_rate(task_type=TaskType.CODING)",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 69,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "neo4j_connector",
                          "type": "Neo4jConnector"
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize ExperienceLogger with a Neo4j connector."
                    },
                    {
                      "name": "log_success",
                      "line": 78,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "task_id",
                          "type": "str"
                        },
                        {
                          "name": "task_type",
                          "type": "TaskType"
                        },
                        {
                          "name": "prompt_version",
                          "type": "str"
                        },
                        {
                          "name": "model_used",
                          "type": "str"
                        },
                        {
                          "name": "tokens_used",
                          "type": "int"
                        },
                        {
                          "name": "cost_usd",
                          "type": "float"
                        },
                        {
                          "name": "duration_ms",
                          "type": "int"
                        },
                        {
                          "name": "retries",
                          "type": "int",
                          "default": "0",
                          "optional": true
                        },
                        {
                          "name": "skills",
                          "type": "list[Skill] | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "artifacts",
                          "type": "list[Artifact] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "str",
                      "description": "Log a successful task completion experience."
                    },
                    {
                      "name": "log_failure",
                      "line": 140,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "task_id",
                          "type": "str"
                        },
                        {
                          "name": "task_type",
                          "type": "TaskType"
                        },
                        {
                          "name": "prompt_version",
                          "type": "str"
                        },
                        {
                          "name": "model_used",
                          "type": "str"
                        },
                        {
                          "name": "tokens_used",
                          "type": "int"
                        },
                        {
                          "name": "cost_usd",
                          "type": "float"
                        },
                        {
                          "name": "duration_ms",
                          "type": "int"
                        },
                        {
                          "name": "error_message",
                          "type": "str"
                        },
                        {
                          "name": "error_type",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "retries",
                          "type": "int",
                          "default": "0",
                          "optional": true
                        },
                        {
                          "name": "skills",
                          "type": "list[Skill] | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "artifacts",
                          "type": "list[Artifact] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "str",
                      "description": "Log a failed task attempt."
                    },
                    {
                      "name": "_create_skill_relationships",
                      "line": 208,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "exp_node_id",
                          "type": "str"
                        },
                        {
                          "name": "skills",
                          "type": "list[Skill]"
                        }
                      ],
                      "return_type": "None",
                      "description": "Create USED_SKILL relationships between Experience and Skill nodes."
                    },
                    {
                      "name": "_create_artifact_relationships",
                      "line": 224,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "exp_node_id",
                          "type": "str"
                        },
                        {
                          "name": "artifacts",
                          "type": "list[Artifact]"
                        }
                      ],
                      "return_type": "None",
                      "description": "Create PRODUCED relationships between Experience and Artifact nodes."
                    },
                    {
                      "name": "get_or_create_skill",
                      "line": 243,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "skill",
                          "type": "Skill"
                        }
                      ],
                      "return_type": "str",
                      "description": "Get an existing skill or create a new one."
                    },
                    {
                      "name": "query_similar_experiences",
                      "line": 272,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "query",
                          "type": "ExperienceQuery"
                        }
                      ],
                      "return_type": "list[Experience]",
                      "description": "Query for similar experiences based on criteria."
                    },
                    {
                      "name": "calculate_success_rate",
                      "line": 336,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "task_type",
                          "type": "TaskType | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "model_used",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "SuccessRate",
                      "description": "Calculate success rate for a task type and/or model."
                    },
                    {
                      "name": "get_experience_by_id",
                      "line": 395,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "experience_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "Experience | None",
                      "description": "Retrieve an experience by its Neo4j element ID."
                    },
                    {
                      "name": "get_related_skills",
                      "line": 417,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "experience_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[Skill]",
                      "description": "Get skills related to an experience via USED_SKILL relationship."
                    },
                    {
                      "name": "get_related_artifacts",
                      "line": 449,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "experience_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[Artifact]",
                      "description": "Get artifacts produced by an experience via PRODUCED relationship."
                    },
                    {
                      "name": "add_insight",
                      "line": 479,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "experience_id",
                          "type": "str"
                        },
                        {
                          "name": "insight",
                          "type": "Insight"
                        }
                      ],
                      "return_type": "str",
                      "description": "Add an insight to an experience via REFLECTED_AS relationship."
                    },
                    {
                      "name": "log_batch",
                      "line": 507,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "experiences",
                          "type": "list[Experience]"
                        }
                      ],
                      "return_type": "list[str]",
                      "description": "Log multiple experiences in batch."
                    },
                    {
                      "name": "_dict_to_experience",
                      "line": 528,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "data",
                          "type": "dict[str, str | int | float | bool]"
                        }
                      ],
                      "return_type": "Experience",
                      "description": "Convert a Neo4j record dict to an Experience object."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.evolution.schemas",
                  "names": [
                    "Artifact",
                    "ArtifactType",
                    "Experience",
                    "ExperienceQuery",
                    "Insight",
                    "Skill",
                    "SuccessRate",
                    "TaskType"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.memory.neo4j",
                  "names": [
                    "Neo4jConnector"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "ExperienceLogger"
              ]
            }
          ]
        },
        "workflow": {
          "name": "workflow",
          "path": "src/daw_agents/workflow",
          "description": "",
          "modules": [
            {
              "name": "rule_enforcer.py",
              "path": "daw_agents/workflow/rule_enforcer.py",
              "description": "Rule Enforcement module for coding style and linting integration.",
              "classes": [
                {
                  "name": "CursorRule",
                  "line": 61,
                  "description": "Model for a rule defined in .cursorrules file.\n\nAttributes:\n    name: Unique identifier for the rule\n    description: Human-readable description of the rule\n    severity: Severity level (default WARNING)\n    pattern: Optional regex pattern for custom pattern matching\n    language: Optional language filter (python, typescript, etc.)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "name",
                      "line": 72,
                      "type": "str"
                    },
                    {
                      "name": "description",
                      "line": 73,
                      "type": "str"
                    },
                    {
                      "name": "severity",
                      "line": 74,
                      "type": "RuleSeverity"
                    },
                    {
                      "name": "pattern",
                      "line": 75,
                      "type": "str | None"
                    },
                    {
                      "name": "language",
                      "line": 76,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "LintViolation",
                  "line": 79,
                  "description": "Model for a single lint violation.\n\nAttributes:\n    file_path: Path to the file with the violation\n    line: Line number of the violation\n    column: Column number of the violation\n    code: Lint rule code (e.g., E501, no-unused-vars)\n    message: Human-readable description of the violation\n    severity: Severity level\n    fixable: Whether this violation can be auto-fixed\n    fix_suggestion: Optional suggestion for how to fix",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "file_path",
                      "line": 93,
                      "type": "str"
                    },
                    {
                      "name": "line",
                      "line": 94,
                      "type": "int"
                    },
                    {
                      "name": "column",
                      "line": 95,
                      "type": "int"
                    },
                    {
                      "name": "code",
                      "line": 96,
                      "type": "str"
                    },
                    {
                      "name": "message",
                      "line": 97,
                      "type": "str"
                    },
                    {
                      "name": "severity",
                      "line": 98,
                      "type": "RuleSeverity"
                    },
                    {
                      "name": "fixable",
                      "line": 99,
                      "type": "bool"
                    },
                    {
                      "name": "fix_suggestion",
                      "line": 100,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "LintResult",
                  "line": 103,
                  "description": "Model for lint check result.\n\nAttributes:\n    success: Whether the lint check passed (no errors)\n    violations: List of lint violations found\n    files_checked: Number of files that were checked\n    auto_fixes_applied: Number of auto-fixes that were applied",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "error_count",
                      "line": 119,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "int",
                      "description": "Count violations with ERROR severity."
                    },
                    {
                      "name": "warning_count",
                      "line": 124,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "int",
                      "description": "Count violations with WARNING severity."
                    }
                  ],
                  "properties": [
                    {
                      "name": "success",
                      "line": 113,
                      "type": "bool"
                    },
                    {
                      "name": "violations",
                      "line": 114,
                      "type": "list[LintViolation]"
                    },
                    {
                      "name": "files_checked",
                      "line": 115,
                      "type": "int"
                    },
                    {
                      "name": "auto_fixes_applied",
                      "line": 116,
                      "type": "int"
                    }
                  ]
                },
                {
                  "name": "CursorRulesParser",
                  "line": 129,
                  "description": "Parser for .cursorrules files.\n\nSupports two formats:\n1. YAML format with explicit rule definitions\n2. Markdown format with rule descriptions",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 137,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Initialize the parser."
                    },
                    {
                      "name": "parse",
                      "line": 141,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "list[CursorRule]",
                      "description": "Parse a .cursorrules file and extract rules."
                    },
                    {
                      "name": "_parse_yaml_rules",
                      "line": 169,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "rules_data",
                          "type": "list[dict[str, Any]]"
                        }
                      ],
                      "return_type": "list[CursorRule]",
                      "description": "Parse rules from YAML format."
                    },
                    {
                      "name": "_parse_markdown_rules",
                      "line": 198,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "content",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[CursorRule]",
                      "description": "Parse rules from markdown format."
                    },
                    {
                      "name": "_generate_rule_name",
                      "line": 238,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "description",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Generate a rule name from description."
                    }
                  ]
                },
                {
                  "name": "RuffRunner",
                  "line": 254,
                  "description": "Runner for Ruff Python linter.\n\nAttributes:\n    config_path: Optional path to pyproject.toml or ruff.toml\n    select: List of rule codes to enable\n    ignore: List of rule codes to ignore",
                  "decorators": [
                    "dataclass"
                  ],
                  "methods": [
                    {
                      "name": "is_available",
                      "line": 267,
                      "visibility": "public",
                      "async": false,
                      "return_type": "bool",
                      "description": "Check if ruff is available in the system."
                    },
                    {
                      "name": "check",
                      "line": 277,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "LintResult",
                      "description": "Run ruff check on the given path."
                    },
                    {
                      "name": "fix",
                      "line": 318,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "LintResult",
                      "description": "Run ruff check with --fix on the given path."
                    },
                    {
                      "name": "_parse_output",
                      "line": 366,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "output",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[LintViolation]",
                      "description": "Parse ruff text output into violations."
                    },
                    {
                      "name": "_count_python_files",
                      "line": 407,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "int",
                      "description": "Count Python files in directory."
                    }
                  ],
                  "properties": [
                    {
                      "name": "config_path",
                      "line": 263,
                      "type": "Path | None"
                    },
                    {
                      "name": "select",
                      "line": 264,
                      "type": "list[str]"
                    },
                    {
                      "name": "ignore",
                      "line": 265,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "ESLintRunner",
                  "line": 422,
                  "description": "Runner for ESLint TypeScript/JavaScript linter.\n\nAttributes:\n    config_path: Optional path to eslint.config.mjs\n    extensions: List of file extensions to check",
                  "decorators": [
                    "dataclass"
                  ],
                  "methods": [
                    {
                      "name": "is_available",
                      "line": 433,
                      "visibility": "public",
                      "async": false,
                      "return_type": "bool",
                      "description": "Check if eslint is available in the system."
                    },
                    {
                      "name": "check",
                      "line": 444,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "LintResult",
                      "description": "Run eslint check on the given path."
                    },
                    {
                      "name": "fix",
                      "line": 480,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "LintResult",
                      "description": "Run eslint with --fix on the given path."
                    },
                    {
                      "name": "_parse_json_output",
                      "line": 516,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "output",
                          "type": "str"
                        }
                      ],
                      "return_type": "list[LintViolation]",
                      "description": "Parse ESLint JSON output into violations."
                    },
                    {
                      "name": "_count_ts_files",
                      "line": 557,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "int",
                      "description": "Count TypeScript/JavaScript files in directory."
                    }
                  ],
                  "properties": [
                    {
                      "name": "config_path",
                      "line": 430,
                      "type": "Path | None"
                    },
                    {
                      "name": "extensions",
                      "line": 431,
                      "type": "list[str]"
                    }
                  ]
                },
                {
                  "name": "RuleEnforcer",
                  "line": 574,
                  "description": "Main class for enforcing coding rules and linting.\n\nIntegrates Ruff (Python), ESLint (TypeScript), and custom .cursorrules\nto provide a comprehensive rule enforcement system for the Developer\nAgent's Green phase.\n\nAttributes:\n    cursorrules_path: Path to .cursorrules file\n    ruff_runner: Ruff linter runner\n    eslint_runner: ESLint runner\n    severity_threshold: Minimum severity to fail gate check\n    exclude_patterns: Glob patterns to exclude from checking\n    timeout: Timeout for lint operations in seconds",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 590,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "cursorrules_path",
                          "type": "Path | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "ruff_runner",
                          "type": "RuffRunner | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "eslint_runner",
                          "type": "ESLintRunner | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "severity_threshold",
                          "type": "RuleSeverity",
                          "default": "RuleSeverity.ERROR",
                          "optional": true
                        },
                        {
                          "name": "exclude_patterns",
                          "type": "list[str] | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "timeout",
                          "type": "float",
                          "default": "60.0",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the RuleEnforcer."
                    },
                    {
                      "name": "from_config",
                      "line": 622,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "config",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "RuleEnforcer",
                      "description": "Create RuleEnforcer from configuration dictionary."
                    },
                    {
                      "name": "load_cursor_rules",
                      "line": 657,
                      "visibility": "public",
                      "async": false,
                      "return_type": "list[CursorRule]",
                      "description": "Load rules from .cursorrules file."
                    },
                    {
                      "name": "check",
                      "line": 671,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        },
                        {
                          "name": "apply_cursor_rules",
                          "type": "bool",
                          "default": "False",
                          "optional": true
                        }
                      ],
                      "return_type": "LintResult",
                      "description": "Check the given path for lint violations."
                    },
                    {
                      "name": "fix",
                      "line": 732,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "LintResult",
                      "description": "Apply auto-fixes to the given path."
                    },
                    {
                      "name": "gate_check",
                      "line": 785,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        },
                        {
                          "name": "auto_fix",
                          "type": "bool",
                          "default": "False",
                          "optional": true
                        }
                      ],
                      "return_type": "tuple[bool, LintResult]",
                      "description": "Perform gate check for Developer workflow's Green phase."
                    },
                    {
                      "name": "_apply_cursor_rules",
                      "line": 828,
                      "visibility": "protected",
                      "async": true,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "list[LintViolation]",
                      "description": "Apply custom .cursorrules patterns to files."
                    },
                    {
                      "name": "_get_language",
                      "line": 884,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "str | None",
                      "description": "Determine language from file extension."
                    },
                    {
                      "name": "generate_report",
                      "line": 905,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "result",
                          "type": "LintResult"
                        }
                      ],
                      "return_type": "str",
                      "description": "Generate a human-readable lint report."
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "RuleSeverity",
                  "kind": "enum",
                  "line": 50,
                  "description": "Severity levels for lint violations.\n\nHigher values indicate more severe violations.",
                  "members": [
                    {
                      "name": "INFO",
                      "value": "1"
                    },
                    {
                      "name": "WARNING",
                      "value": "2"
                    },
                    {
                      "name": "ERROR",
                      "value": "3"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "asyncio"
                },
                {
                  "module": "json"
                },
                {
                  "module": "logging"
                },
                {
                  "module": "re"
                },
                {
                  "module": "dataclasses",
                  "names": [
                    "dataclass",
                    "field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "IntEnum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pathlib",
                  "names": [
                    "Path"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING",
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "yaml"
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/workflow/__init__.py",
              "description": "Workflow package for agent orchestration and enforcement.",
              "imports": [
                {
                  "module": "daw_agents.workflow.rule_enforcer",
                  "names": [
                    "CursorRule",
                    "CursorRulesParser",
                    "ESLintRunner",
                    "LintResult",
                    "LintViolation",
                    "RuffRunner",
                    "RuleEnforcer",
                    "RuleSeverity"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "CursorRule",
                "CursorRulesParser",
                "ESLintRunner",
                "LintResult",
                "LintViolation",
                "RuleEnforcer",
                "RuleSeverity",
                "RuffRunner"
              ]
            }
          ]
        },
        "api": {
          "name": "api",
          "path": "src/daw_agents/api",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/api/__init__.py",
              "description": "DAW Agents API package.",
              "imports": [
                {
                  "module": "daw_agents.api.routes",
                  "names": [
                    "WorkflowManager",
                    "create_router",
                    "create_trace_websocket_router"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.api.schemas",
                  "names": [
                    "ApprovalAction",
                    "ApprovalRequest",
                    "ApprovalResponse",
                    "ChatRequest",
                    "ChatResponse",
                    "DeleteWorkflowResponse",
                    "ErrorResponse",
                    "WebSocketMessage",
                    "WorkflowStatus",
                    "WorkflowStatusEnum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.api.websocket",
                  "names": [
                    "AgentStreamCallback",
                    "AgentStreamEvent",
                    "EventType",
                    "MaxConnectionsExceededError",
                    "MessageQueue",
                    "ReconnectionConfig",
                    "WebSocketAuthError",
                    "WebSocketManager",
                    "create_websocket_router",
                    "get_default_manager"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "create_router",
                "create_trace_websocket_router",
                "WorkflowManager",
                "WorkflowStatusEnum",
                "ApprovalAction",
                "ChatRequest",
                "ChatResponse",
                "WorkflowStatus",
                "ApprovalRequest",
                "ApprovalResponse",
                "DeleteWorkflowResponse",
                "WebSocketMessage",
                "ErrorResponse",
                "AgentStreamCallback",
                "AgentStreamEvent",
                "EventType",
                "MaxConnectionsExceededError",
                "MessageQueue",
                "ReconnectionConfig",
                "WebSocketAuthError",
                "WebSocketManager",
                "create_websocket_router",
                "get_default_manager"
              ]
            },
            {
              "name": "schemas.py",
              "path": "daw_agents/api/schemas.py",
              "description": "Pydantic schemas for API request/response models.",
              "classes": [
                {
                  "name": "ChatRequest",
                  "line": 48,
                  "description": "Request schema for POST /api/chat endpoint.\n\nAttributes:\n    message: The user's message to the Planner agent.\n    context: Optional context dictionary for additional information.\n    workflow_id: Optional workflow ID to continue an existing conversation.",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "message_must_not_be_empty",
                      "line": 75,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "field_validator",
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "v",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Validate that message is not empty or whitespace only."
                    }
                  ],
                  "properties": [
                    {
                      "name": "message",
                      "line": 57,
                      "type": "str"
                    },
                    {
                      "name": "context",
                      "line": 63,
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "workflow_id",
                      "line": 68,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "ChatResponse",
                  "line": 82,
                  "description": "Response schema for POST /api/chat endpoint.\n\nAttributes:\n    workflow_id: The ID of the created or continued workflow.\n    message: Response message from the Planner agent.\n    status: Current status of the workflow.\n    tasks_generated: Number of tasks generated (if PRD phase complete).\n    phase: Current phase of the workflow (interview, roundtable, etc.).",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "workflow_id",
                      "line": 93,
                      "type": "str"
                    },
                    {
                      "name": "message",
                      "line": 97,
                      "type": "str"
                    },
                    {
                      "name": "status",
                      "line": 101,
                      "type": "WorkflowStatusEnum | str"
                    },
                    {
                      "name": "tasks_generated",
                      "line": 105,
                      "type": "int | None"
                    },
                    {
                      "name": "phase",
                      "line": 109,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "WorkflowStatus",
                  "line": 120,
                  "description": "Response schema for GET /api/workflow/{id} endpoint.\n\nProvides detailed information about the current state of a workflow.\n\nAttributes:\n    id: Unique identifier for the workflow.\n    status: Current status of the workflow.\n    phase: Current phase (interview, roundtable, generate_prd, etc.).\n    progress: Progress percentage (0.0 to 1.0).\n    tasks_total: Total number of tasks in the workflow.\n    tasks_completed: Number of completed tasks.\n    current_task: Description of the current task being executed.\n    created_at: Timestamp when the workflow was created.\n    updated_at: Timestamp of last update.\n    error_message: Error message if status is 'error'.\n    user_id: ID of the user who owns this workflow.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "id",
                      "line": 139,
                      "type": "str"
                    },
                    {
                      "name": "status",
                      "line": 140,
                      "type": "WorkflowStatusEnum | str"
                    },
                    {
                      "name": "phase",
                      "line": 143,
                      "type": "str | None"
                    },
                    {
                      "name": "progress",
                      "line": 147,
                      "type": "float | None"
                    },
                    {
                      "name": "tasks_total",
                      "line": 153,
                      "type": "int | None"
                    },
                    {
                      "name": "tasks_completed",
                      "line": 157,
                      "type": "int | None"
                    },
                    {
                      "name": "current_task",
                      "line": 161,
                      "type": "str | None"
                    },
                    {
                      "name": "created_at",
                      "line": 165,
                      "type": "datetime"
                    },
                    {
                      "name": "updated_at",
                      "line": 166,
                      "type": "datetime"
                    },
                    {
                      "name": "error_message",
                      "line": 167,
                      "type": "str | None"
                    },
                    {
                      "name": "user_id",
                      "line": 171,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "ApprovalRequest",
                  "line": 182,
                  "description": "Request schema for POST /api/workflow/{id}/approve endpoint.\n\nAllows users to approve, reject, or request modifications to a workflow.\n\nAttributes:\n    action: The approval action (approve, reject, modify).\n    comment: Optional comment explaining the decision.\n    modifications: Optional modifications to apply (for modify action).",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "action",
                      "line": 193,
                      "type": "ApprovalAction"
                    },
                    {
                      "name": "comment",
                      "line": 197,
                      "type": "str | None"
                    },
                    {
                      "name": "modifications",
                      "line": 201,
                      "type": "dict[str, Any] | None"
                    }
                  ]
                },
                {
                  "name": "ApprovalResponse",
                  "line": 207,
                  "description": "Response schema for POST /api/workflow/{id}/approve endpoint.\n\nAttributes:\n    success: Whether the approval action was successful.\n    workflow_id: The workflow ID.\n    new_status: The new status after the action.\n    message: Description of what happened.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "success",
                      "line": 217,
                      "type": "bool"
                    },
                    {
                      "name": "workflow_id",
                      "line": 218,
                      "type": "str"
                    },
                    {
                      "name": "new_status",
                      "line": 219,
                      "type": "str"
                    },
                    {
                      "name": "message",
                      "line": 220,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "DeleteWorkflowResponse",
                  "line": 228,
                  "description": "Response schema for DELETE /api/workflow/{id} endpoint.\n\nAttributes:\n    success: Whether the deletion was successful.\n    workflow_id: The deleted workflow ID.\n    message: Description of what happened.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "success",
                      "line": 237,
                      "type": "bool"
                    },
                    {
                      "name": "workflow_id",
                      "line": 238,
                      "type": "str"
                    },
                    {
                      "name": "message",
                      "line": 239,
                      "type": "str"
                    }
                  ]
                },
                {
                  "name": "WebSocketMessage",
                  "line": 247,
                  "description": "Message format for WebSocket communication.\n\nAttributes:\n    type: Message type (ping, pong, state_update, error, etc.).\n    data: Optional data payload.\n    timestamp: Message timestamp.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "type",
                      "line": 256,
                      "type": "str"
                    },
                    {
                      "name": "data",
                      "line": 257,
                      "type": "dict[str, Any] | None"
                    },
                    {
                      "name": "timestamp",
                      "line": 260,
                      "type": "datetime"
                    }
                  ]
                },
                {
                  "name": "ErrorResponse",
                  "line": 270,
                  "description": "Standard error response schema.\n\nAttributes:\n    detail: Error detail message.\n    error_code: Optional error code for programmatic handling.",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "detail",
                      "line": 278,
                      "type": "str"
                    },
                    {
                      "name": "error_code",
                      "line": 279,
                      "type": "str | None"
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "WorkflowStatusEnum",
                  "kind": "enum",
                  "line": 21,
                  "description": "Status values for a workflow.",
                  "members": [
                    {
                      "name": "PENDING",
                      "value": "pending"
                    },
                    {
                      "name": "PLANNING",
                      "value": "planning"
                    },
                    {
                      "name": "AWAITING_APPROVAL",
                      "value": "awaiting_approval"
                    },
                    {
                      "name": "EXECUTING",
                      "value": "executing"
                    },
                    {
                      "name": "VALIDATING",
                      "value": "validating"
                    },
                    {
                      "name": "COMPLETED",
                      "value": "completed"
                    },
                    {
                      "name": "FAILED",
                      "value": "failed"
                    },
                    {
                      "name": "CANCELLED",
                      "value": "cancelled"
                    },
                    {
                      "name": "ERROR",
                      "value": "error"
                    }
                  ]
                },
                {
                  "name": "ApprovalAction",
                  "kind": "enum",
                  "line": 35,
                  "description": "Actions for workflow approval.",
                  "members": [
                    {
                      "name": "APPROVE",
                      "value": "approve"
                    },
                    {
                      "name": "REJECT",
                      "value": "reject"
                    },
                    {
                      "name": "MODIFY",
                      "value": "modify"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field",
                    "field_validator"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "WorkflowStatusEnum",
                "ApprovalAction",
                "ChatRequest",
                "ChatResponse",
                "WorkflowStatus",
                "ApprovalRequest",
                "ApprovalResponse",
                "DeleteWorkflowResponse",
                "WebSocketMessage",
                "ErrorResponse"
              ]
            },
            {
              "name": "websocket.py",
              "path": "daw_agents/api/websocket.py",
              "description": "WebSocket Streaming Infrastructure for Real-Time Agent Updates.",
              "classes": [
                {
                  "name": "AgentStreamEvent",
                  "line": 42,
                  "description": "Model for events streamed to WebSocket clients.\n\nAttributes:\n    event_type: The type of event (STATE_CHANGE, THOUGHT, etc.)\n    workflow_id: ID of the workflow this event belongs to\n    data: Event-specific data payload\n    timestamp: When the event occurred (defaults to now)",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "event_type",
                      "line": 52,
                      "type": "EventType"
                    },
                    {
                      "name": "workflow_id",
                      "line": 53,
                      "type": "str"
                    },
                    {
                      "name": "data",
                      "line": 54,
                      "type": "dict[str, Any]"
                    },
                    {
                      "name": "timestamp",
                      "line": 55,
                      "type": "datetime"
                    }
                  ]
                },
                {
                  "name": "ReconnectionConfig",
                  "line": 58,
                  "description": "Configuration for client reconnection with exponential backoff.\n\nAttributes:\n    initial_delay_ms: Initial delay before first retry (default 1000ms)\n    max_delay_ms: Maximum delay between retries (default 30000ms)\n    max_retries: Maximum number of retry attempts (default 5)\n    backoff_multiplier: Multiplier for exponential backoff (default 2.0)",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "calculate_delay",
                      "line": 73,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "attempt",
                          "type": "int"
                        }
                      ],
                      "return_type": "int",
                      "description": "Calculate delay for a given retry attempt using exponential backoff."
                    }
                  ],
                  "properties": [
                    {
                      "name": "initial_delay_ms",
                      "line": 68,
                      "type": "int"
                    },
                    {
                      "name": "max_delay_ms",
                      "line": 69,
                      "type": "int"
                    },
                    {
                      "name": "max_retries",
                      "line": 70,
                      "type": "int"
                    },
                    {
                      "name": "backoff_multiplier",
                      "line": 71,
                      "type": "float"
                    }
                  ]
                },
                {
                  "name": "MessageQueue",
                  "line": 86,
                  "description": "Queue for storing messages during client disconnection.\n\nMessages are queued when clients disconnect and replayed on reconnection.\nOld messages are evicted when the queue exceeds max_size.\n\nAttributes:\n    _max_size: Maximum number of messages to store\n    _messages: List of queued messages",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 97,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "max_size",
                          "type": "int",
                          "default": "100",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the message queue."
                    },
                    {
                      "name": "__len__",
                      "line": 106,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "int",
                      "description": "Return the number of messages in the queue."
                    },
                    {
                      "name": "add",
                      "line": 110,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "event",
                          "type": "AgentStreamEvent"
                        }
                      ],
                      "return_type": "None",
                      "description": "Add an event to the queue, evicting oldest if full."
                    },
                    {
                      "name": "get_all",
                      "line": 120,
                      "visibility": "public",
                      "async": false,
                      "return_type": "list[AgentStreamEvent]",
                      "description": "Get all messages and clear the queue."
                    }
                  ]
                },
                {
                  "name": "MaxConnectionsExceededError",
                  "line": 131,
                  "description": "Exception raised when max connections per workflow is exceeded.",
                  "bases": [
                    "Exception"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 134,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "workflow_id",
                          "type": "str"
                        },
                        {
                          "name": "max_connections",
                          "type": "int"
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the exception."
                    }
                  ]
                },
                {
                  "name": "WebSocketAuthError",
                  "line": 148,
                  "description": "Exception raised for WebSocket authentication errors.",
                  "bases": [
                    "Exception"
                  ],
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 151,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "message",
                          "type": "str"
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the exception."
                    }
                  ]
                },
                {
                  "name": "WebSocketManager",
                  "line": 161,
                  "description": "Manager for WebSocket connections organized by workflow.\n\nHandles connection lifecycle, broadcasting events, and message queueing\nfor reconnecting clients.\n\nAttributes:\n    _connections: Dict mapping workflow_id to list of WebSocket connections\n    _max_connections_per_workflow: Max concurrent connections per workflow\n    _enable_message_queue: Whether to queue messages for disconnected clients\n    _message_queues: Dict mapping workflow_id to MessageQueue",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 174,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "max_connections_per_workflow",
                          "type": "int",
                          "default": "100",
                          "optional": true
                        },
                        {
                          "name": "enable_message_queue",
                          "type": "bool",
                          "default": "False",
                          "optional": true
                        },
                        {
                          "name": "message_queue_size",
                          "type": "int",
                          "default": "100",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the WebSocket manager."
                    },
                    {
                      "name": "connect",
                      "line": 195,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "workflow_id",
                          "type": "str"
                        },
                        {
                          "name": "websocket",
                          "type": "WebSocket"
                        },
                        {
                          "name": "replay_missed",
                          "type": "bool",
                          "default": "False",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Accept and register a new WebSocket connection."
                    },
                    {
                      "name": "disconnect",
                      "line": 235,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "workflow_id",
                          "type": "str"
                        },
                        {
                          "name": "websocket",
                          "type": "WebSocket"
                        }
                      ],
                      "return_type": "None",
                      "description": "Remove a WebSocket connection."
                    },
                    {
                      "name": "get_connection_count",
                      "line": 252,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "workflow_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "int",
                      "description": "Get the number of active connections for a workflow."
                    },
                    {
                      "name": "broadcast",
                      "line": 263,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "workflow_id",
                          "type": "str"
                        },
                        {
                          "name": "event",
                          "type": "AgentStreamEvent"
                        }
                      ],
                      "return_type": "None",
                      "description": "Broadcast an event to all clients connected to a workflow."
                    }
                  ]
                },
                {
                  "name": "AgentStreamCallback",
                  "line": 298,
                  "description": "LangGraph callback handler for streaming agent events to WebSocket clients.\n\nThis callback integrates with LangGraph workflows to emit real-time events\nfor state transitions, LLM thinking, tool calls, and errors.\n\nAttributes:\n    _manager: The WebSocketManager to use for broadcasting\n    _workflow_id: The workflow ID to broadcast events for",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 309,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "manager",
                          "type": "WebSocketManager"
                        },
                        {
                          "name": "workflow_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize the callback."
                    },
                    {
                      "name": "on_chain_start",
                      "line": 319,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "serialized",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "inputs",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "None",
                      "description": "Handle chain start event - emits STATE_CHANGE."
                    },
                    {
                      "name": "on_chain_end",
                      "line": 343,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "outputs",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "None",
                      "description": "Handle chain end event - emits STATE_CHANGE."
                    },
                    {
                      "name": "on_chain_error",
                      "line": 364,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "error",
                          "type": "BaseException"
                        }
                      ],
                      "return_type": "None",
                      "description": "Handle chain error - emits ERROR event."
                    },
                    {
                      "name": "on_llm_start",
                      "line": 385,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "serialized",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "prompts",
                          "type": "Sequence[str]"
                        }
                      ],
                      "return_type": "None",
                      "description": "Handle LLM start - emits THOUGHT event."
                    },
                    {
                      "name": "on_tool_start",
                      "line": 410,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "serialized",
                          "type": "dict[str, Any]"
                        },
                        {
                          "name": "input_str",
                          "type": "str"
                        }
                      ],
                      "return_type": "None",
                      "description": "Handle tool start - emits TOOL_CALL event."
                    },
                    {
                      "name": "on_tool_end",
                      "line": 434,
                      "visibility": "public",
                      "async": true,
                      "parameters": [
                        {
                          "name": "output",
                          "type": "str"
                        }
                      ],
                      "return_type": "None",
                      "description": "Handle tool end - emits TOOL_CALL completed event."
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "create_websocket_router",
                  "line": 457,
                  "description": "Create a FastAPI router with WebSocket endpoints.",
                  "async": false,
                  "return_type": "APIRouter",
                  "parameters": [
                    {
                      "name": "manager",
                      "type": "WebSocketManager | None",
                      "default": "None",
                      "optional": true
                    }
                  ]
                },
                {
                  "name": "get_default_manager",
                  "line": 524,
                  "description": "Get or create the default WebSocketManager instance.",
                  "async": false,
                  "return_type": "WebSocketManager"
                }
              ],
              "types": [
                {
                  "name": "EventType",
                  "kind": "enum",
                  "line": 31,
                  "description": "Types of events that can be streamed to clients.",
                  "members": [
                    {
                      "name": "STATE_CHANGE",
                      "value": "STATE_CHANGE"
                    },
                    {
                      "name": "THOUGHT",
                      "value": "THOUGHT"
                    },
                    {
                      "name": "TOOL_CALL",
                      "value": "TOOL_CALL"
                    },
                    {
                      "name": "ERROR",
                      "value": "ERROR"
                    },
                    {
                      "name": "CONNECTED",
                      "value": "CONNECTED"
                    },
                    {
                      "name": "DISCONNECTED",
                      "value": "DISCONNECTED"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "logging"
                },
                {
                  "module": "collections",
                  "names": [
                    "defaultdict"
                  ],
                  "is_relative": false
                },
                {
                  "module": "collections.abc",
                  "names": [
                    "Sequence"
                  ],
                  "is_relative": false
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "Enum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING",
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "fastapi",
                  "names": [
                    "APIRouter",
                    "Query",
                    "WebSocket",
                    "WebSocketDisconnect"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "AgentStreamCallback",
                "AgentStreamEvent",
                "EventType",
                "MaxConnectionsExceededError",
                "MessageQueue",
                "ReconnectionConfig",
                "WebSocketAuthError",
                "WebSocketManager",
                "create_websocket_router",
                "get_default_manager"
              ]
            },
            {
              "name": "routes.py",
              "path": "daw_agents/api/routes.py",
              "description": "FastAPI route endpoints for DAW Workbench.",
              "classes": [
                {
                  "name": "WorkflowManager",
                  "line": 46,
                  "description": "Manages workflow state and operations.\n\nThis is an in-memory implementation for MVP.\nProduction implementation should use Redis/Neo4j persistence.",
                  "methods": [
                    {
                      "name": "create_workflow",
                      "line": 57,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "user_id",
                          "type": "str"
                        },
                        {
                          "name": "message",
                          "type": "str"
                        },
                        {
                          "name": "context",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "dict[str, Any]",
                      "description": "Create a new workflow."
                    },
                    {
                      "name": "get_workflow",
                      "line": 103,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "workflow_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "dict[str, Any] | None",
                      "description": "Get a workflow by ID."
                    },
                    {
                      "name": "update_workflow",
                      "line": 115,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "workflow_id",
                          "type": "str"
                        },
                        {
                          "name": "updates",
                          "type": "dict[str, Any]"
                        }
                      ],
                      "return_type": "dict[str, Any] | None",
                      "description": "Update a workflow."
                    },
                    {
                      "name": "delete_workflow",
                      "line": 136,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "workflow_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Delete a workflow."
                    },
                    {
                      "name": "user_owns_workflow",
                      "line": 160,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "parameters": [
                        {
                          "name": "user_id",
                          "type": "str"
                        },
                        {
                          "name": "workflow_id",
                          "type": "str"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if a user owns a workflow."
                    },
                    {
                      "name": "clear_all",
                      "line": 176,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "return_type": "None",
                      "description": "Clear all workflows (for testing)."
                    }
                  ],
                  "properties": [
                    {
                      "name": "_workflows",
                      "line": 53,
                      "type": "dict[str, dict[str, Any]]"
                    },
                    {
                      "name": "_user_workflows",
                      "line": 54,
                      "type": "dict[str, list[str]]"
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "create_auth_dependency",
                  "line": 187,
                  "description": "Create a FastAPI dependency for Clerk authentication.",
                  "async": false,
                  "return_type": "Any",
                  "parameters": [
                    {
                      "name": "config",
                      "type": "ClerkConfig"
                    }
                  ]
                },
                {
                  "name": "create_router",
                  "line": 231,
                  "description": "Create the API router with all endpoints.",
                  "async": false,
                  "return_type": "APIRouter",
                  "parameters": [
                    {
                      "name": "config",
                      "type": "ClerkConfig"
                    }
                  ]
                },
                {
                  "name": "create_trace_websocket_router",
                  "line": 550,
                  "description": "Create the WebSocket router for real-time trace updates.",
                  "async": false,
                  "return_type": "APIRouter",
                  "parameters": [
                    {
                      "name": "config",
                      "type": "ClerkConfig"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "logging"
                },
                {
                  "module": "uuid"
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "fastapi",
                  "names": [
                    "APIRouter",
                    "Depends",
                    "HTTPException",
                    "Query",
                    "WebSocket",
                    "status"
                  ],
                  "is_relative": false
                },
                {
                  "module": "fastapi.security",
                  "names": [
                    "HTTPAuthorizationCredentials",
                    "HTTPBearer"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.api.schemas",
                  "names": [
                    "ApprovalAction",
                    "ApprovalRequest",
                    "ApprovalResponse",
                    "ChatRequest",
                    "ChatResponse",
                    "DeleteWorkflowResponse",
                    "WebSocketMessage",
                    "WorkflowStatus",
                    "WorkflowStatusEnum"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.auth.clerk",
                  "names": [
                    "ClerkConfig",
                    "ClerkJWTVerifier",
                    "ClerkUser"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "create_router",
                "create_trace_websocket_router",
                "WorkflowManager"
              ]
            }
          ]
        },
        "workers": {
          "name": "workers",
          "path": "src/daw_agents/workers",
          "description": "",
          "modules": [
            {
              "name": "tasks.py",
              "path": "daw_agents/workers/tasks.py",
              "description": "Celery task definitions for DAW agent workflows.",
              "classes": [
                {
                  "name": "BaseTaskWithRetry",
                  "line": 34,
                  "description": "Base task class with exponential backoff retry configuration.\n\nThis class provides common retry configuration for all DAW agent tasks:\n- autoretry_for: Exceptions to retry on\n- max_retries: Maximum retry attempts\n- retry_backoff: Exponential backoff enabled\n- retry_backoff_max: Maximum backoff delay\n- retry_jitter: Add randomness to prevent thundering herd",
                  "bases": [
                    "Task"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "run_planner",
                  "line": 58,
                  "description": "Execute planner/taskmaster agent workflow.",
                  "async": false,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "task_id",
                      "type": "str"
                    },
                    {
                      "name": "input_data",
                      "type": "dict[str, Any]"
                    },
                    {
                      "name": "options",
                      "type": "dict[str, Any] | None",
                      "default": "None",
                      "optional": true
                    }
                  ]
                },
                {
                  "name": "run_executor",
                  "line": 131,
                  "description": "Execute developer agent workflow.",
                  "async": false,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "task_id",
                      "type": "str"
                    },
                    {
                      "name": "input_data",
                      "type": "dict[str, Any]"
                    },
                    {
                      "name": "options",
                      "type": "dict[str, Any] | None",
                      "default": "None",
                      "optional": true
                    }
                  ]
                },
                {
                  "name": "run_validator",
                  "line": 204,
                  "description": "Execute validator agent workflow.",
                  "async": false,
                  "return_type": "dict[str, Any]",
                  "parameters": [
                    {
                      "name": "task_id",
                      "type": "str"
                    },
                    {
                      "name": "input_data",
                      "type": "dict[str, Any]"
                    },
                    {
                      "name": "options",
                      "type": "dict[str, Any] | None",
                      "default": "None",
                      "optional": true
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "DEFAULT_RETRY_POLICY",
                  "line": 31
                }
              ],
              "imports": [
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "celery",
                  "names": [
                    "Task"
                  ],
                  "is_relative": false
                },
                {
                  "module": "celery.utils.log",
                  "names": [
                    "get_task_logger"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.workers.celery_app",
                  "names": [
                    "QUEUE_EXECUTOR",
                    "QUEUE_PLANNER",
                    "QUEUE_VALIDATOR",
                    "RetryPolicy",
                    "celery_app"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "celery_app.py",
              "path": "daw_agents/workers/celery_app.py",
              "description": "Celery application configuration for background task processing.",
              "classes": [
                {
                  "name": "RetryPolicy",
                  "line": 32,
                  "description": "Configuration for task retry with exponential backoff.\n\nThis dataclass defines retry behavior for Celery tasks including:\n- Maximum number of retries\n- Exponential backoff settings\n- Jitter to prevent thundering herd\n\nAttributes:\n    max_retries: Maximum number of retry attempts (default: 5)\n    retry_backoff: Enable exponential backoff (default: True)\n    retry_backoff_base: Base delay in seconds for backoff (default: 2)\n    retry_backoff_max: Maximum backoff delay in seconds (default: 600)\n    retry_jitter: Add randomness to backoff (default: True)",
                  "decorators": [
                    "dataclass"
                  ],
                  "methods": [
                    {
                      "name": "as_dict",
                      "line": 54,
                      "visibility": "public",
                      "async": false,
                      "return_type": "dict[str, Any]",
                      "description": "Export retry policy as dict for Celery task configuration."
                    }
                  ],
                  "properties": [
                    {
                      "name": "max_retries",
                      "line": 48,
                      "type": "int"
                    },
                    {
                      "name": "retry_backoff",
                      "line": 49,
                      "type": "bool"
                    },
                    {
                      "name": "retry_backoff_base",
                      "line": 50,
                      "type": "int"
                    },
                    {
                      "name": "retry_backoff_max",
                      "line": 51,
                      "type": "int"
                    },
                    {
                      "name": "retry_jitter",
                      "line": 52,
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "CeleryConfig",
                  "line": 69,
                  "description": "Configuration for Celery workers.\n\nThis dataclass manages Celery configuration including:\n- Broker URL (from RedisConfig)\n- Result backend\n- Worker concurrency and prefetch settings\n- Task acknowledgment settings\n- Serialization settings\n\nAttributes:\n    broker_url: Redis broker URL (from RedisConfig)\n    result_backend: Redis result backend URL\n    worker_concurrency: Number of concurrent worker processes\n    worker_prefetch_multiplier: Prefetch multiplier per worker\n    task_acks_late: Acknowledge tasks after execution (default: True)\n    task_reject_on_worker_lost: Reject tasks if worker is lost (default: True)\n    task_serializer: Serializer for tasks (default: \"json\")\n    result_serializer: Serializer for results (default: \"json\")\n    accept_content: Accepted content types (default: [\"json\"])\n    result_expires: Result expiration in seconds (default: 86400 = 24h)\n    task_time_limit: Hard time limit in seconds (default: 3600 = 1h)\n    task_soft_time_limit: Soft time limit in seconds (default: 3300 = 55min)\n    visibility_timeout: Broker visibility timeout (default: 43200 = 12h)",
                  "decorators": [
                    "dataclass"
                  ],
                  "methods": [
                    {
                      "name": "__post_init__",
                      "line": 109,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Initialize values from RedisConfig and environment if not provided."
                    }
                  ],
                  "properties": [
                    {
                      "name": "broker_url",
                      "line": 95,
                      "type": "str"
                    },
                    {
                      "name": "result_backend",
                      "line": 96,
                      "type": "str"
                    },
                    {
                      "name": "worker_concurrency",
                      "line": 97,
                      "type": "int"
                    },
                    {
                      "name": "worker_prefetch_multiplier",
                      "line": 98,
                      "type": "int"
                    },
                    {
                      "name": "task_acks_late",
                      "line": 99,
                      "type": "bool"
                    },
                    {
                      "name": "task_reject_on_worker_lost",
                      "line": 100,
                      "type": "bool"
                    },
                    {
                      "name": "task_serializer",
                      "line": 101,
                      "type": "str"
                    },
                    {
                      "name": "result_serializer",
                      "line": 102,
                      "type": "str"
                    },
                    {
                      "name": "accept_content",
                      "line": 103,
                      "type": "list[str]"
                    },
                    {
                      "name": "result_expires",
                      "line": 104,
                      "type": "int"
                    },
                    {
                      "name": "task_time_limit",
                      "line": 105,
                      "type": "int"
                    },
                    {
                      "name": "task_soft_time_limit",
                      "line": 106,
                      "type": "int"
                    },
                    {
                      "name": "visibility_timeout",
                      "line": 107,
                      "type": "int"
                    }
                  ]
                }
              ],
              "functions": [
                {
                  "name": "create_celery_app",
                  "line": 128,
                  "description": "Create and configure a Celery application.",
                  "async": false,
                  "return_type": "Celery",
                  "parameters": [
                    {
                      "name": "name",
                      "type": "str",
                      "default": "'daw_agents'",
                      "optional": true
                    },
                    {
                      "name": "config",
                      "type": "CeleryConfig | None",
                      "default": "None",
                      "optional": true
                    }
                  ]
                }
              ],
              "constants": [
                {
                  "name": "QUEUE_DEFAULT",
                  "line": 25,
                  "value": "celery",
                  "type": "str"
                },
                {
                  "name": "QUEUE_PLANNER",
                  "line": 26,
                  "value": "planner_queue",
                  "type": "str"
                },
                {
                  "name": "QUEUE_EXECUTOR",
                  "line": 27,
                  "value": "executor_queue",
                  "type": "str"
                },
                {
                  "name": "QUEUE_VALIDATOR",
                  "line": 28,
                  "value": "validator_queue",
                  "type": "str"
                }
              ],
              "imports": [
                {
                  "module": "os"
                },
                {
                  "module": "dataclasses",
                  "names": [
                    "dataclass",
                    "field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "celery",
                  "names": [
                    "Celery"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.config.redis",
                  "names": [
                    "RedisConfig"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/workers/__init__.py",
              "description": "Celery workers for background task processing.",
              "imports": [
                {
                  "module": "daw_agents.workers.celery_app",
                  "names": [
                    "QUEUE_DEFAULT",
                    "QUEUE_EXECUTOR",
                    "QUEUE_PLANNER",
                    "QUEUE_VALIDATOR",
                    "CeleryConfig",
                    "RetryPolicy",
                    "celery_app",
                    "create_celery_app"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.workers.tasks",
                  "names": [
                    "run_executor",
                    "run_planner",
                    "run_validator"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "CeleryConfig",
                "RetryPolicy",
                "QUEUE_DEFAULT",
                "QUEUE_PLANNER",
                "QUEUE_EXECUTOR",
                "QUEUE_VALIDATOR",
                "celery_app",
                "create_celery_app",
                "run_planner",
                "run_executor",
                "run_validator"
              ]
            }
          ]
        },
        "ops": {
          "name": "ops",
          "path": "src/daw_agents/ops",
          "description": "",
          "modules": [
            {
              "name": "helicone.py",
              "path": "daw_agents/ops/helicone.py",
              "description": "Helicone Observability Integration for DAW Agent Workbench.",
              "classes": [
                {
                  "name": "HeliconeConfig",
                  "line": 32,
                  "description": "Configuration for Helicone observability proxy.\n\nHelicone proxies LLM API calls to track costs, latency, and usage.\n\nAttributes:\n    api_key: Helicone API key for authentication\n    base_url: Helicone proxy base URL\n    enabled: Whether Helicone tracking is enabled",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "disable_if_no_api_key",
                      "line": 48,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "model_validator"
                      ],
                      "return_type": "HeliconeConfig",
                      "description": "Disable Helicone if no API key is provided."
                    },
                    {
                      "name": "from_env",
                      "line": 55,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "return_type": "HeliconeConfig",
                      "description": "Load configuration from environment variables."
                    }
                  ],
                  "properties": [
                    {
                      "name": "api_key",
                      "line": 43,
                      "type": "str | None"
                    },
                    {
                      "name": "base_url",
                      "line": 44,
                      "type": "str"
                    },
                    {
                      "name": "enabled",
                      "line": 45,
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "CacheConfig",
                  "line": 70,
                  "description": "Configuration for Helicone response caching.\n\nCaching helps reduce costs and latency by storing previous\nLLM responses for identical requests.\n\nAttributes:\n    enabled: Whether caching is enabled\n    max_age_seconds: Cache TTL in seconds (default: 30 days)\n    bucket_max_size: Max variations to cache per request pattern\n    seed: Optional deterministic seed for cache key",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "enabled",
                      "line": 83,
                      "type": "bool"
                    },
                    {
                      "name": "max_age_seconds",
                      "line": 84,
                      "type": "int"
                    },
                    {
                      "name": "bucket_max_size",
                      "line": 85,
                      "type": "int"
                    },
                    {
                      "name": "seed",
                      "line": 86,
                      "type": "str | None"
                    }
                  ]
                },
                {
                  "name": "RequestMetadata",
                  "line": 89,
                  "description": "Metadata to attach to LLM requests for tracking.\n\nThis metadata is used to:\n- Track costs per user/project\n- Group requests by session\n- Add custom properties for filtering\n\nAttributes:\n    user_id: User ID for per-user cost tracking\n    session_id: Session ID for grouping requests\n    project_id: Project ID for project-level tracking\n    agent_type: Agent type (planner, executor, validator, etc.)\n    custom_properties: Additional key-value pairs for tracking",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "user_id",
                      "line": 105,
                      "type": "str | None"
                    },
                    {
                      "name": "session_id",
                      "line": 106,
                      "type": "str | None"
                    },
                    {
                      "name": "project_id",
                      "line": 107,
                      "type": "str | None"
                    },
                    {
                      "name": "agent_type",
                      "line": 108,
                      "type": "str | None"
                    },
                    {
                      "name": "custom_properties",
                      "line": 109,
                      "type": "dict[str, str]"
                    }
                  ]
                },
                {
                  "name": "HeliconeHeaders",
                  "line": 112,
                  "description": "Builder for Helicone HTTP headers.\n\nCreates the proper header format for:\n- Authentication (Helicone-Auth)\n- User tracking (Helicone-User-Id)\n- Session tracking (Helicone-Session-Id)\n- Custom properties (Helicone-Property-*)\n- Caching (Helicone-Cache-Enabled, Cache-Control, etc.)\n\nUsage:\n    config = HeliconeConfig(api_key=\"hlc_...\")\n    metadata = RequestMetadata(user_id=\"user-123\")\n    headers = HeliconeHeaders(config=config, metadata=metadata)\n    result = headers.build()  # Returns dict of headers",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 129,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "HeliconeConfig"
                        },
                        {
                          "name": "metadata",
                          "type": "RequestMetadata | None",
                          "default": "None",
                          "optional": true
                        },
                        {
                          "name": "cache_config",
                          "type": "CacheConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize HeliconeHeaders builder."
                    },
                    {
                      "name": "_normalize_property_name",
                      "line": 146,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "name",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Normalize a property name to Title-Case format."
                    },
                    {
                      "name": "build",
                      "line": 162,
                      "visibility": "public",
                      "async": false,
                      "return_type": "dict[str, str]",
                      "description": "Build Helicone headers dictionary."
                    }
                  ]
                },
                {
                  "name": "TrackedRequest",
                  "line": 209,
                  "description": "Model for a tracked LLM request.\n\nStores data about a single LLM API call for cost tracking\nand analytics.\n\nAttributes:\n    request_id: Unique identifier for the request\n    model: Model used (e.g., \"gpt-4o\", \"claude-3-5-sonnet\")\n    task_type: Type of task (planning, coding, validation, fast)\n    tokens_prompt: Number of prompt tokens\n    tokens_completion: Number of completion tokens\n    cost_usd: Cost in USD\n    latency_ms: Request latency in milliseconds\n    cached: Whether the response was served from cache\n    timestamp: When the request was made\n    metadata: Additional metadata attached to the request",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "total_tokens",
                      "line": 240,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "int",
                      "description": "Get total token count (prompt + completion)."
                    }
                  ],
                  "properties": [
                    {
                      "name": "request_id",
                      "line": 228,
                      "type": "str"
                    },
                    {
                      "name": "model",
                      "line": 229,
                      "type": "str"
                    },
                    {
                      "name": "task_type",
                      "line": 230,
                      "type": "str"
                    },
                    {
                      "name": "tokens_prompt",
                      "line": 231,
                      "type": "int"
                    },
                    {
                      "name": "tokens_completion",
                      "line": 232,
                      "type": "int"
                    },
                    {
                      "name": "cost_usd",
                      "line": 233,
                      "type": "float"
                    },
                    {
                      "name": "latency_ms",
                      "line": 234,
                      "type": "int"
                    },
                    {
                      "name": "cached",
                      "line": 235,
                      "type": "bool"
                    },
                    {
                      "name": "timestamp",
                      "line": 236,
                      "type": "datetime"
                    },
                    {
                      "name": "metadata",
                      "line": 237,
                      "type": "dict[str, Any]"
                    }
                  ]
                },
                {
                  "name": "TimeRange",
                  "line": 245,
                  "description": "Time range for cost summary queries.\n\nAttributes:\n    start: Start of the time range\n    end: End of the time range",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "last_hour",
                      "line": 257,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "return_type": "TimeRange",
                      "description": "Create a TimeRange for the last hour."
                    },
                    {
                      "name": "last_day",
                      "line": 263,
                      "visibility": "public",
                      "async": false,
                      "class_method": true,
                      "decorators": [
                        "classmethod"
                      ],
                      "return_type": "TimeRange",
                      "description": "Create a TimeRange for the last 24 hours."
                    }
                  ],
                  "properties": [
                    {
                      "name": "start",
                      "line": 253,
                      "type": "datetime"
                    },
                    {
                      "name": "end",
                      "line": 254,
                      "type": "datetime"
                    }
                  ]
                },
                {
                  "name": "CostSummary",
                  "line": 270,
                  "description": "Summary of costs for a time period.\n\nAttributes:\n    total_cost_usd: Total cost in USD\n    total_requests: Total number of requests\n    total_tokens: Total token count\n    cached_requests: Number of cached requests\n    cache_hit_rate: Ratio of cached to total requests\n    breakdown: Optional breakdown by model or task type",
                  "decorators": [
                    "dataclass"
                  ],
                  "properties": [
                    {
                      "name": "total_cost_usd",
                      "line": 282,
                      "type": "float"
                    },
                    {
                      "name": "total_requests",
                      "line": 283,
                      "type": "int"
                    },
                    {
                      "name": "total_tokens",
                      "line": 284,
                      "type": "int"
                    },
                    {
                      "name": "cached_requests",
                      "line": 285,
                      "type": "int"
                    },
                    {
                      "name": "cache_hit_rate",
                      "line": 286,
                      "type": "float"
                    },
                    {
                      "name": "breakdown",
                      "line": 287,
                      "type": "dict[str, dict[str, Any]]"
                    }
                  ]
                },
                {
                  "name": "HeliconeTracker",
                  "line": 290,
                  "description": "Tracker for LLM request costs and usage.\n\nProvides:\n- Request tracking with metadata\n- Cost aggregation over time ranges\n- Breakdown by model or task type\n- Cache hit rate statistics\n\nUsage:\n    config = HeliconeConfig(api_key=\"hlc_...\")\n    tracker = HeliconeTracker(config=config)\n\n    # Track a request\n    request_id = tracker.track_request(\n        model=\"gpt-4o\",\n        task_type=\"coding\",\n        tokens_prompt=100,\n        tokens_completion=50,\n        cost_usd=0.015,\n        latency_ms=1500,\n    )\n\n    # Get cost summary\n    summary = tracker.get_cost_summary(TimeRange.last_hour())",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 317,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "HeliconeConfig"
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize HeliconeTracker."
                    },
                    {
                      "name": "track_request",
                      "line": 326,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "model",
                          "type": "str"
                        },
                        {
                          "name": "task_type",
                          "type": "str"
                        },
                        {
                          "name": "tokens_prompt",
                          "type": "int"
                        },
                        {
                          "name": "tokens_completion",
                          "type": "int"
                        },
                        {
                          "name": "cost_usd",
                          "type": "float"
                        },
                        {
                          "name": "latency_ms",
                          "type": "int"
                        },
                        {
                          "name": "cached",
                          "type": "bool",
                          "default": "False",
                          "optional": true
                        },
                        {
                          "name": "metadata",
                          "type": "dict[str, Any] | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "str",
                      "description": "Track an LLM request."
                    },
                    {
                      "name": "get_cost_summary",
                      "line": 367,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "time_range",
                          "type": "TimeRange"
                        },
                        {
                          "name": "group_by",
                          "type": "str | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "CostSummary",
                      "description": "Get cost summary for a time range."
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "os"
                },
                {
                  "module": "re"
                },
                {
                  "module": "uuid"
                },
                {
                  "module": "dataclasses",
                  "names": [
                    "dataclass",
                    "field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime",
                    "timedelta"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Any"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field",
                    "model_validator"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "drift_detector.py",
              "path": "daw_agents/ops/drift_detector.py",
              "description": "Drift Detection Metrics module for DAW Agent Workbench.",
              "classes": [
                {
                  "name": "DriftMetric",
                  "line": 73,
                  "description": "Model for a single drift metric measurement.\n\nRepresents the comparison of current metric value against baseline,\nwith calculated deviation and assigned severity.\n\nAttributes:\n    metric_type: Type of metric being measured\n    metric_name: Human-readable name for the metric\n    task_type: Type of task this metric applies to\n    baseline: Baseline value for comparison\n    current: Current measured value\n    deviation_pct: Percentage deviation from baseline\n    severity: Assigned severity level\n    recommended_actions: List of recommended actions\n    timestamp: When the measurement was taken",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "calculate_deviation",
                      "line": 102,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "model_validator"
                      ],
                      "return_type": "DriftMetric",
                      "description": "Auto-calculate deviation percentage if not provided."
                    }
                  ],
                  "properties": [
                    {
                      "name": "metric_type",
                      "line": 91,
                      "type": "MetricType"
                    },
                    {
                      "name": "metric_name",
                      "line": 92,
                      "type": "str"
                    },
                    {
                      "name": "task_type",
                      "line": 93,
                      "type": "str"
                    },
                    {
                      "name": "baseline",
                      "line": 94,
                      "type": "float"
                    },
                    {
                      "name": "current",
                      "line": 95,
                      "type": "float"
                    },
                    {
                      "name": "deviation_pct",
                      "line": 96,
                      "type": "float | None"
                    },
                    {
                      "name": "severity",
                      "line": 97,
                      "type": "DriftSeverity"
                    },
                    {
                      "name": "recommended_actions",
                      "line": 98,
                      "type": "list[DriftAction]"
                    },
                    {
                      "name": "timestamp",
                      "line": 99,
                      "type": "datetime"
                    }
                  ]
                },
                {
                  "name": "TaskMetrics",
                  "line": 117,
                  "description": "Model for tracking per-task measurements.\n\nCaptures all relevant metrics for a single task execution\nthat will be compared against baselines.\n\nAttributes:\n    task_id: Unique identifier for the task\n    task_type: Category of task (coding, planning, validation, etc.)\n    tool_usage_count: Number of tool calls made\n    step_count: Number of reasoning steps taken\n    context_tokens: Current tokens in context window\n    context_window_size: Maximum context window size\n    retry_count: Number of retries performed\n    token_cost_usd: Total token cost in USD\n    timestamp: When the metrics were recorded",
                  "bases": [
                    "BaseModel"
                  ],
                  "methods": [
                    {
                      "name": "context_utilization_pct",
                      "line": 146,
                      "visibility": "public",
                      "async": false,
                      "decorators": [
                        "property"
                      ],
                      "return_type": "float",
                      "description": "Calculate context window utilization percentage."
                    }
                  ],
                  "properties": [
                    {
                      "name": "task_id",
                      "line": 135,
                      "type": "str"
                    },
                    {
                      "name": "task_type",
                      "line": 136,
                      "type": "str"
                    },
                    {
                      "name": "tool_usage_count",
                      "line": 137,
                      "type": "int"
                    },
                    {
                      "name": "step_count",
                      "line": 138,
                      "type": "int"
                    },
                    {
                      "name": "context_tokens",
                      "line": 139,
                      "type": "int"
                    },
                    {
                      "name": "context_window_size",
                      "line": 140,
                      "type": "int"
                    },
                    {
                      "name": "retry_count",
                      "line": 141,
                      "type": "int"
                    },
                    {
                      "name": "token_cost_usd",
                      "line": 142,
                      "type": "float"
                    },
                    {
                      "name": "timestamp",
                      "line": 143,
                      "type": "datetime"
                    }
                  ]
                },
                {
                  "name": "BaselineConfig",
                  "line": 151,
                  "description": "Configuration for drift detection thresholds.\n\nDefault values are based on FR-05.1 requirements:\n- Tool Usage: +50% = WARNING\n- Step Count: +100% = CRITICAL (pause agent)\n- Context Utilization: >90% = WARNING (force compaction)\n- Retry Rate: >3x baseline = CRITICAL (escalate)\n- Token Cost: +200% = WARNING (budget alert)\n\nAttributes:\n    tool_usage_warning_pct: Percentage increase to trigger WARNING\n    step_count_critical_pct: Percentage increase to trigger CRITICAL\n    context_utilization_warning_pct: Utilization percentage for WARNING\n    retry_rate_critical_multiplier: Multiplier of baseline for CRITICAL\n    token_cost_warning_pct: Percentage increase for budget WARNING",
                  "bases": [
                    "BaseModel"
                  ],
                  "properties": [
                    {
                      "name": "tool_usage_warning_pct",
                      "line": 169,
                      "type": "float"
                    },
                    {
                      "name": "step_count_critical_pct",
                      "line": 170,
                      "type": "float"
                    },
                    {
                      "name": "context_utilization_warning_pct",
                      "line": 171,
                      "type": "float"
                    },
                    {
                      "name": "retry_rate_critical_multiplier",
                      "line": 172,
                      "type": "float"
                    },
                    {
                      "name": "token_cost_warning_pct",
                      "line": 173,
                      "type": "float"
                    }
                  ]
                },
                {
                  "name": "DriftDetector",
                  "line": 176,
                  "description": "Main class for detecting behavioral drift in agent execution.\n\nCompares current task metrics against recorded baselines to\nidentify when agent behavior deviates from expected patterns.\n\nThresholds (from FR-05.1):\n- Tool Usage Frequency: +50% deviation = WARNING (log warning)\n- Reasoning Step Count: +100% increase = CRITICAL (pause agent)\n- Context Window Utilization: >90% = WARNING (force compaction)\n- Retry Rate: >3x baseline = CRITICAL (escalate to human)\n- Token Cost per Task: +200% increase = WARNING (budget alert)\n\nUsage:\n    detector = DriftDetector()\n\n    # Record baselines from historical data\n    detector.record_baseline(\n        task_type=\"coding\",\n        tool_usage_count=10.0,\n        step_count=20.0,\n        context_tokens=50000.0,\n        retry_count=1.0,\n        token_cost_usd=0.10,\n    )\n\n    # Evaluate current task\n    metrics = TaskMetrics(\n        task_id=\"TEST-001\",\n        task_type=\"coding\",\n        tool_usage_count=15,  # 50% increase\n        step_count=22,\n        context_tokens=55000,\n        context_window_size=128000,\n        retry_count=1,\n        token_cost_usd=0.11,\n    )\n    results = detector.evaluate(metrics)\n\n    # Check severity and actions\n    max_severity = detector.get_max_severity(results)\n    actions = detector.get_recommended_actions(results)",
                  "methods": [
                    {
                      "name": "__init__",
                      "line": 220,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "config",
                          "type": "BaselineConfig | None",
                          "default": "None",
                          "optional": true
                        }
                      ],
                      "return_type": "None",
                      "description": "Initialize DriftDetector with optional custom configuration."
                    },
                    {
                      "name": "record_baseline",
                      "line": 229,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "task_type",
                          "type": "str"
                        },
                        {
                          "name": "tool_usage_count",
                          "type": "float"
                        },
                        {
                          "name": "step_count",
                          "type": "float"
                        },
                        {
                          "name": "context_tokens",
                          "type": "float"
                        },
                        {
                          "name": "retry_count",
                          "type": "float"
                        },
                        {
                          "name": "token_cost_usd",
                          "type": "float"
                        }
                      ],
                      "return_type": "None",
                      "description": "Record baseline metrics for a task type."
                    },
                    {
                      "name": "evaluate",
                      "line": 259,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "TaskMetrics"
                        }
                      ],
                      "return_type": "list[DriftMetric]",
                      "description": "Evaluate current task metrics against baselines."
                    },
                    {
                      "name": "_evaluate_tool_usage",
                      "line": 299,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "TaskMetrics"
                        },
                        {
                          "name": "baseline",
                          "type": "dict[str, float]"
                        }
                      ],
                      "return_type": "DriftMetric",
                      "description": "Evaluate tool usage drift."
                    },
                    {
                      "name": "_evaluate_step_count",
                      "line": 332,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "TaskMetrics"
                        },
                        {
                          "name": "baseline",
                          "type": "dict[str, float]"
                        }
                      ],
                      "return_type": "DriftMetric",
                      "description": "Evaluate reasoning step count drift."
                    },
                    {
                      "name": "_evaluate_context_utilization",
                      "line": 365,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "TaskMetrics"
                        }
                      ],
                      "return_type": "DriftMetric",
                      "description": "Evaluate context window utilization."
                    },
                    {
                      "name": "_evaluate_retry_rate",
                      "line": 394,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "TaskMetrics"
                        },
                        {
                          "name": "baseline",
                          "type": "dict[str, float]"
                        }
                      ],
                      "return_type": "DriftMetric",
                      "description": "Evaluate retry rate drift."
                    },
                    {
                      "name": "_evaluate_token_cost",
                      "line": 430,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "metrics",
                          "type": "TaskMetrics"
                        },
                        {
                          "name": "baseline",
                          "type": "dict[str, float]"
                        }
                      ],
                      "return_type": "DriftMetric",
                      "description": "Evaluate token cost drift."
                    },
                    {
                      "name": "get_max_severity",
                      "line": 465,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "results",
                          "type": "list[DriftMetric]"
                        }
                      ],
                      "return_type": "DriftSeverity",
                      "description": "Get the maximum severity from drift results."
                    },
                    {
                      "name": "get_recommended_actions",
                      "line": 479,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "results",
                          "type": "list[DriftMetric]"
                        }
                      ],
                      "return_type": "set[DriftAction]",
                      "description": "Collect all recommended actions from drift results."
                    }
                  ]
                }
              ],
              "types": [
                {
                  "name": "DriftSeverity",
                  "kind": "enum",
                  "line": 31,
                  "description": "Severity levels for drift detection.\n\nOrdered from lowest to highest severity for comparison.",
                  "members": [
                    {
                      "name": "NORMAL",
                      "value": "0"
                    },
                    {
                      "name": "WARNING",
                      "value": "1"
                    },
                    {
                      "name": "CRITICAL",
                      "value": "2"
                    },
                    {
                      "name": "EMERGENCY",
                      "value": "3"
                    }
                  ]
                },
                {
                  "name": "DriftAction",
                  "kind": "enum",
                  "line": 43,
                  "description": "Recommended actions when drift is detected.\n\nActions are escalating based on severity:\n- LOG: Log the event for analysis\n- ALERT: Send notification to monitoring\n- PAUSE_AGENT: Stop agent execution\n- FORCE_COMPACTION: Trigger context compaction\n- BUDGET_ALERT: Alert about cost overrun\n- ESCALATE_TO_HUMAN: Require human intervention",
                  "members": [
                    {
                      "name": "LOG"
                    },
                    {
                      "name": "ALERT"
                    },
                    {
                      "name": "PAUSE_AGENT"
                    },
                    {
                      "name": "FORCE_COMPACTION"
                    },
                    {
                      "name": "BUDGET_ALERT"
                    },
                    {
                      "name": "ESCALATE_TO_HUMAN"
                    }
                  ]
                },
                {
                  "name": "MetricType",
                  "kind": "enum",
                  "line": 63,
                  "description": "Types of metrics tracked for drift detection.",
                  "members": [
                    {
                      "name": "TOOL_USAGE"
                    },
                    {
                      "name": "STEP_COUNT"
                    },
                    {
                      "name": "CONTEXT_UTILIZATION"
                    },
                    {
                      "name": "RETRY_RATE"
                    },
                    {
                      "name": "TOKEN_COST"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "datetime",
                  "names": [
                    "UTC",
                    "datetime"
                  ],
                  "is_relative": false
                },
                {
                  "module": "enum",
                  "names": [
                    "IntEnum",
                    "auto"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pydantic",
                  "names": [
                    "BaseModel",
                    "Field",
                    "model_validator"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "__init__.py",
              "path": "daw_agents/ops/__init__.py",
              "description": "Operations and observability modules for DAW Agent Workbench.",
              "imports": [
                {
                  "module": "daw_agents.ops.drift_detector",
                  "names": [
                    "BaselineConfig",
                    "DriftAction",
                    "DriftDetector",
                    "DriftMetric",
                    "DriftSeverity",
                    "MetricType",
                    "TaskMetrics"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.ops.helicone",
                  "names": [
                    "CacheConfig",
                    "CostSummary",
                    "HeliconeConfig",
                    "HeliconeHeaders",
                    "HeliconeTracker",
                    "RequestMetadata",
                    "TimeRange",
                    "TrackedRequest"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "BaselineConfig",
                "DriftAction",
                "DriftDetector",
                "DriftMetric",
                "DriftSeverity",
                "MetricType",
                "TaskMetrics",
                "CacheConfig",
                "CostSummary",
                "HeliconeConfig",
                "HeliconeHeaders",
                "HeliconeTracker",
                "RequestMetadata",
                "TimeRange",
                "TrackedRequest"
              ]
            }
          ]
        },
        "tdd": {
          "name": "tdd",
          "path": "src/daw_agents/tdd",
          "description": "",
          "modules": [
            {
              "name": "__init__.py",
              "path": "daw_agents/tdd/__init__.py",
              "description": "TDD Guard Package.",
              "imports": [
                {
                  "module": "daw_agents.tdd.exceptions",
                  "names": [
                    "TDDViolation",
                    "TDDViolationError"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.tdd.guard",
                  "names": [
                    "TDDGuard",
                    "TestResult"
                  ],
                  "is_relative": false
                }
              ],
              "exports": [
                "TDDGuard",
                "TestResult",
                "TDDViolation",
                "TDDViolationError"
              ]
            },
            {
              "name": "exceptions.py",
              "path": "daw_agents/tdd/exceptions.py",
              "description": "TDD Guard Exceptions.",
              "classes": [
                {
                  "name": "TDDViolationError",
                  "line": 17,
                  "description": "Exception raised when TDD workflow rules are violated.\n\nThis exception is raised when:\n- Attempting to write source code without a test file\n- Attempting to write source code when test already passes (skipping RED phase)\n- Attempting to mark GREEN phase complete when tests still fail",
                  "bases": [
                    "Exception"
                  ],
                  "decorators": [
                    "dataclass"
                  ],
                  "methods": [
                    {
                      "name": "__post_init__",
                      "line": 33,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Initialize the exception with the message."
                    },
                    {
                      "name": "__str__",
                      "line": 37,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "str",
                      "description": "Return a string representation of the violation."
                    }
                  ],
                  "properties": [
                    {
                      "name": "message",
                      "line": 27,
                      "type": "str"
                    },
                    {
                      "name": "phase",
                      "line": 28,
                      "type": "str"
                    },
                    {
                      "name": "test_file",
                      "line": 29,
                      "type": "str"
                    },
                    {
                      "name": "source_file",
                      "line": 30,
                      "type": "str | None"
                    },
                    {
                      "name": "test_result",
                      "line": 31,
                      "type": "TestResult | None"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "dataclasses",
                  "names": [
                    "dataclass",
                    "field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "TYPE_CHECKING"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.tdd.guard",
                  "names": [
                    "TestResult"
                  ],
                  "is_relative": false
                }
              ]
            },
            {
              "name": "guard.py",
              "path": "daw_agents/tdd/guard.py",
              "description": "TDD Guard - Red-Green-Refactor Enforcement Logic.",
              "classes": [
                {
                  "name": "TestResult",
                  "line": 22,
                  "description": "Result of running a test file.\n\nAttributes:\n    passed: Whether all tests in the file passed.\n    test_file: Path to the test file that was run.\n    output: Full pytest output.\n    error: Error message if tests failed.\n    exit_code: Pytest exit code.\n    duration_ms: Time taken to run tests in milliseconds.",
                  "decorators": [
                    "dataclass"
                  ],
                  "properties": [
                    {
                      "name": "passed",
                      "line": 35,
                      "type": "bool"
                    },
                    {
                      "name": "test_file",
                      "line": 36,
                      "type": "str"
                    },
                    {
                      "name": "output",
                      "line": 37,
                      "type": "str"
                    },
                    {
                      "name": "error",
                      "line": 38,
                      "type": "str | None"
                    },
                    {
                      "name": "exit_code",
                      "line": 39,
                      "type": "int | None"
                    },
                    {
                      "name": "duration_ms",
                      "line": 40,
                      "type": "float | None"
                    }
                  ]
                },
                {
                  "name": "TDDGuard",
                  "line": 47,
                  "description": "TDD Guard enforces test-driven development workflow.\n\nThis guard ensures that:\n1. A test file exists before implementation code can be written\n2. The test fails (RED phase) before implementation is allowed\n3. The test passes (GREEN phase) after implementation\n\nAttributes:\n    project_root: Root directory of the project.\n    src_dir: Name of the source directory (default: \"src\").\n    tests_dir: Name of the tests directory (default: \"tests\").\n    test_patterns: List of test file naming patterns.\n    pytest_args: Additional arguments to pass to pytest.\n    strict: If True, enforce TDD for all files without exception.\n    excluded_patterns: File patterns to exclude from TDD enforcement.",
                  "decorators": [
                    "dataclass"
                  ],
                  "methods": [
                    {
                      "name": "__post_init__",
                      "line": 83,
                      "visibility": "protected",
                      "async": false,
                      "return_type": "None",
                      "description": "Ensure project_root is a Path object."
                    },
                    {
                      "name": "get_test_file_path",
                      "line": 88,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "source_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "Path",
                      "description": "Get the expected test file path for a source file."
                    },
                    {
                      "name": "check_test_exists",
                      "line": 121,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "source_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if a test file exists for the given source file."
                    },
                    {
                      "name": "_get_possible_test_dirs",
                      "line": 148,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "source_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "list[Path]",
                      "description": "Get all possible test directory locations for a source file."
                    },
                    {
                      "name": "run_test",
                      "line": 190,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "test_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "TestResult",
                      "description": "Run a test file and return the result."
                    },
                    {
                      "name": "_extract_error",
                      "line": 249,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "output",
                          "type": "str"
                        }
                      ],
                      "return_type": "str",
                      "description": "Extract the error message from pytest output."
                    },
                    {
                      "name": "enforce_red_phase",
                      "line": 265,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "test_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "None",
                      "description": "Enforce RED phase - test must fail."
                    },
                    {
                      "name": "enforce_green_phase",
                      "line": 289,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "test_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "None",
                      "description": "Enforce GREEN phase - test must pass."
                    },
                    {
                      "name": "can_write_source",
                      "line": 313,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "source_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if source file can be written according to TDD rules."
                    },
                    {
                      "name": "_find_test_file",
                      "line": 354,
                      "visibility": "protected",
                      "async": false,
                      "parameters": [
                        {
                          "name": "source_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "Path | None",
                      "description": "Find the test file for a source file."
                    },
                    {
                      "name": "get_workflow_state",
                      "line": 372,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "source_file",
                          "type": "Path"
                        }
                      ],
                      "return_type": "WorkflowState",
                      "description": "Get the current workflow state for a source file."
                    },
                    {
                      "name": "is_excluded",
                      "line": 387,
                      "visibility": "public",
                      "async": false,
                      "parameters": [
                        {
                          "name": "file_path",
                          "type": "Path"
                        }
                      ],
                      "return_type": "bool",
                      "description": "Check if a file is excluded from TDD enforcement."
                    }
                  ],
                  "properties": [
                    {
                      "name": "project_root",
                      "line": 66,
                      "type": "Path"
                    },
                    {
                      "name": "src_dir",
                      "line": 67,
                      "type": "str"
                    },
                    {
                      "name": "tests_dir",
                      "line": 68,
                      "type": "str"
                    },
                    {
                      "name": "test_patterns",
                      "line": 69,
                      "type": "list[str]"
                    },
                    {
                      "name": "pytest_args",
                      "line": 72,
                      "type": "list[str]"
                    },
                    {
                      "name": "strict",
                      "line": 73,
                      "type": "bool"
                    },
                    {
                      "name": "excluded_patterns",
                      "line": 74,
                      "type": "list[str]"
                    },
                    {
                      "name": "_workflow_states",
                      "line": 79,
                      "type": "dict[str, WorkflowState]"
                    }
                  ]
                }
              ],
              "imports": [
                {
                  "module": "__future__",
                  "names": [
                    "annotations"
                  ],
                  "is_relative": false
                },
                {
                  "module": "fnmatch"
                },
                {
                  "module": "subprocess"
                },
                {
                  "module": "time"
                },
                {
                  "module": "dataclasses",
                  "names": [
                    "dataclass",
                    "field"
                  ],
                  "is_relative": false
                },
                {
                  "module": "pathlib",
                  "names": [
                    "Path"
                  ],
                  "is_relative": false
                },
                {
                  "module": "typing",
                  "names": [
                    "Literal"
                  ],
                  "is_relative": false
                },
                {
                  "module": "daw_agents.tdd.exceptions",
                  "names": [
                    "TDDViolation"
                  ],
                  "is_relative": false
                }
              ]
            }
          ]
        }
      }
    },
    "daw-frontend": {
      "name": "daw-frontend",
      "language": "typescript",
      "path": "packages/daw-frontend",
      "description": "Next.js frontend with React, TypeScript, and Tailwind",
      "domains": {}
    }
  }
}